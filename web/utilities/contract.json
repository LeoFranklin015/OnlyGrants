{
    "address": "0x906a57aCa067178e76e6eBDF4C7b26CBcAEC0Edd",
    "abi": [
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "user",
                    "type": "address"
                },
                {
                    "indexed": false,
                    "internalType": "uint256",
                    "name": "amount",
                    "type": "uint256"
                }
            ],
            "name": "BalanceToppedUp",
            "type": "event"
        },
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": true,
                    "internalType": "uint256",
                    "name": "roundId",
                    "type": "uint256"
                },
                {
                    "indexed": true,
                    "internalType": "uint256",
                    "name": "projectId",
                    "type": "uint256"
                },
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "donor",
                    "type": "address"
                },
                {
                    "indexed": false,
                    "internalType": "euint64",
                    "name": "amount",
                    "type": "uint256"
                }
            ],
            "name": "DonationMade",
            "type": "event"
        },
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": true,
                    "internalType": "uint256",
                    "name": "roundId",
                    "type": "uint256"
                }
            ],
            "name": "FundsDistributed",
            "type": "event"
        },
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": true,
                    "internalType": "uint256",
                    "name": "roundId",
                    "type": "uint256"
                },
                {
                    "indexed": true,
                    "internalType": "uint256",
                    "name": "projectId",
                    "type": "uint256"
                },
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "projectOwner",
                    "type": "address"
                }
            ],
            "name": "ProjectApplied",
            "type": "event"
        },
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": true,
                    "internalType": "uint256",
                    "name": "roundId",
                    "type": "uint256"
                }
            ],
            "name": "RoundCancelled",
            "type": "event"
        },
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": true,
                    "internalType": "uint256",
                    "name": "roundId",
                    "type": "uint256"
                },
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "profileOwner",
                    "type": "address"
                },
                {
                    "indexed": false,
                    "internalType": "uint256",
                    "name": "matchingAmount",
                    "type": "uint256"
                }
            ],
            "name": "RoundCreated",
            "type": "event"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "roundId",
                    "type": "uint256"
                },
                {
                    "internalType": "string",
                    "name": "metadata",
                    "type": "string"
                }
            ],
            "name": "applyForRound",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "",
                    "type": "address"
                }
            ],
            "name": "balances",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "roundId",
                    "type": "uint256"
                }
            ],
            "name": "cancelRound",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "ma",
                    "type": "uint256"
                },
                {
                    "internalType": "string",
                    "name": "m",
                    "type": "string"
                },
                {
                    "internalType": "uint256",
                    "name": "vp",
                    "type": "uint256"
                }
            ],
            "name": "createRound",
            "outputs": [],
            "stateMutability": "payable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "rId",
                    "type": "uint256"
                }
            ],
            "name": "distributeFunds",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "roundId",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "projectId",
                    "type": "uint256"
                },
                {
                    "components": [
                        {
                            "internalType": "bytes",
                            "name": "data",
                            "type": "bytes"
                        }
                    ],
                    "internalType": "struct inEuint64",
                    "name": "amount",
                    "type": "tuple"
                }
            ],
            "name": "donate",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "roundId",
                    "type": "uint256"
                },
                {
                    "internalType": "string",
                    "name": "newMetadata",
                    "type": "string"
                }
            ],
            "name": "editRoundMetadata",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "roundId",
                    "type": "uint256"
                }
            ],
            "name": "finalizeRoundPoll",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "roundId",
                    "type": "uint256"
                }
            ],
            "name": "getRoundPollWinner",
            "outputs": [
                {
                    "internalType": "uint8",
                    "name": "",
                    "type": "uint8"
                },
                {
                    "internalType": "uint16",
                    "name": "",
                    "type": "uint16"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "name": "rounds",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "id",
                    "type": "uint256"
                },
                {
                    "internalType": "address",
                    "name": "profileOwner",
                    "type": "address"
                },
                {
                    "internalType": "string",
                    "name": "metadata",
                    "type": "string"
                },
                {
                    "internalType": "uint256",
                    "name": "matchingAmount",
                    "type": "uint256"
                },
                {
                    "internalType": "bool",
                    "name": "isActive",
                    "type": "bool"
                },
                {
                    "internalType": "uint256",
                    "name": "nextProjectId",
                    "type": "uint256"
                },
                {
                    "internalType": "contract Poll",
                    "name": "poll",
                    "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "topUpBalance",
            "outputs": [],
            "stateMutability": "payable",
            "type": "function"
        }
    ],
    "transactionHash": "0xeef604ad4ad72500c4f5499fef9adf92441a67b609b0005e6cf50eddd02dbade",
    "receipt": {
        "to": null,
        "from": "0x5A4830885f12438E00D8f4d98e9Fe083e707698C",
        "contractAddress": "0x906a57aCa067178e76e6eBDF4C7b26CBcAEC0Edd",
        "transactionIndex": 1,
        "gasUsed": "5171511",
        "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        "blockHash": "0x53c3b60be131f779167fff1af742ddc087239c231d6446f4169f6a35a3aaaf7c",
        "transactionHash": "0xeef604ad4ad72500c4f5499fef9adf92441a67b609b0005e6cf50eddd02dbade",
        "logs": [],
        "blockNumber": 11,
        "cumulativeGasUsed": "5171511",
        "status": 1,
        "byzantium": true
    },
    "args": [],
    "numDeployments": 1,
    "solcInputHash": "3b369cf007041d23e51c32016ca9f6d1",
    "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BalanceToppedUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"donor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"euint64\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DonationMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"FundsDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"projectOwner\",\"type\":\"address\"}],\"name\":\"ProjectApplied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"RoundCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"profileOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"matchingAmount\",\"type\":\"uint256\"}],\"name\":\"RoundCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"name\":\"applyForRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"cancelRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ma\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"m\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"vp\",\"type\":\"uint256\"}],\"name\":\"createRound\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rId\",\"type\":\"uint256\"}],\"name\":\"distributeFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct inEuint64\",\"name\":\"amount\",\"type\":\"tuple\"}],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"newMetadata\",\"type\":\"string\"}],\"name\":\"editRoundMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"finalizeRoundPoll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundPollWinner\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"profileOwner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"matchingAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"nextProjectId\",\"type\":\"uint256\"},{\"internalType\":\"contract Poll\",\"name\":\"poll\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"topUpBalance\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"applyForRound(uint256,string)\":{\"params\":{\"metadata\":\"The project's metadata\",\"roundId\":\"The ID of the round to apply for\"}},\"cancelRound(uint256)\":{\"params\":{\"roundId\":\"The ID of the round to cancel\"}},\"distributeFunds(uint256)\":{\"params\":{\"rId\":\"The ID of the round to distribute funds for\"}},\"donate(uint256,uint256,(bytes))\":{\"params\":{\"amount\":\"The amount of tokens to donate\",\"projectId\":\"The ID of the project\",\"roundId\":\"The ID of the round\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"applyForRound(uint256,string)\":{\"notice\":\"Creates a project to apply for a round\"},\"cancelRound(uint256)\":{\"notice\":\"Allows the round owner to cancel an active round and refund donations\"},\"distributeFunds(uint256)\":{\"notice\":\"Distributes funds for a completed round using quadratic funding\"},\"donate(uint256,uint256,(bytes))\":{\"notice\":\"Allows a user to donate to a specific project in a round\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/OnlyGrantsProtocol.sol\":\"OnlyGrantsProtocol\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@fhenixprotocol/contracts/FHE.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\n// solhint-disable one-contract-per-file\\n\\npragma solidity >=0.8.19 <=0.8.25;\\n\\nimport {Precompiles, FheOps} from \\\"./FheOS.sol\\\";\\n\\ntype ebool is uint256;\\ntype euint8 is uint256;\\ntype euint16 is uint256;\\ntype euint32 is uint256;\\ntype euint64 is uint256;\\ntype euint128 is uint256;\\ntype euint256 is uint256;\\ntype eaddress is uint256;\\n\\nstruct inEbool {\\n    bytes data;\\n}\\nstruct inEuint8 {\\n    bytes data;\\n}\\nstruct inEuint16 {\\n    bytes data;\\n}\\nstruct inEuint32 {\\n    bytes data;\\n}\\nstruct inEuint64 {\\n    bytes data;\\n}\\nstruct inEuint128 {\\n    bytes data;\\n}\\nstruct inEuint256 {\\n    bytes data;\\n}\\nstruct inEaddress {\\n    bytes data;\\n}\\n\\nstruct SealedArray {\\n  bytes[] data;\\n}\\n\\nlibrary Common {\\n    // Values used to communicate types to the runtime.\\n    // Must match values defined in warp-drive protobufs for everything to \\n    // make sense\\n    uint8 internal constant EUINT8_TFHE = 0;\\n    uint8 internal constant EUINT16_TFHE = 1;\\n    uint8 internal constant EUINT32_TFHE = 2;\\n    uint8 internal constant EUINT64_TFHE = 3;\\n    uint8 internal constant EUINT128_TFHE = 4;\\n    uint8 internal constant EUINT256_TFHE = 5;\\n    uint8 internal constant EADDRESS_TFHE = 12;\\n    // uint8 internal constant INT_BGV = 12;\\n    uint8 internal constant EBOOL_TFHE = 13;\\n    \\n    function bigIntToBool(uint256 i) internal pure returns (bool) {\\n        return (i > 0);\\n    }\\n\\n    function bigIntToUint8(uint256 i) internal pure returns (uint8) {\\n        return uint8(i);\\n    }\\n\\n    function bigIntToUint16(uint256 i) internal pure returns (uint16) {\\n        return uint16(i);\\n    }\\n\\n    function bigIntToUint32(uint256 i) internal pure returns (uint32) {\\n        return uint32(i);\\n    }\\n\\n    function bigIntToUint64(uint256 i) internal pure returns (uint64) {\\n        return uint64(i);\\n    }\\n\\n    function bigIntToUint128(uint256 i) internal pure returns (uint128) {\\n        return uint128(i);\\n    }\\n\\n    function bigIntToUint256(uint256 i) internal pure returns (uint256) {\\n        return i;\\n    }\\n\\n    function bigIntToAddress(uint256 i) internal pure returns (address) {\\n      return address(uint160(i));\\n    }\\n    \\n    function toBytes(uint256 x) internal pure returns (bytes memory b) {\\n        b = new bytes(32);\\n        assembly { mstore(add(b, 32), x) }\\n    }\\n}\\n\\nlibrary Impl {\\n    function sealoutput(uint8 utype, uint256 ciphertext, bytes32 publicKey) internal pure returns (string memory reencrypted) {\\n        // Call the sealoutput precompile.\\n        reencrypted = FheOps(Precompiles.Fheos).sealOutput(utype, Common.toBytes(ciphertext), bytes.concat(publicKey));\\n\\n        return reencrypted;\\n    }\\n\\n    function verify(bytes memory _ciphertextBytes, uint8 _toType) internal pure returns (uint256 result) {\\n        bytes memory output;\\n\\n        // Call the verify precompile.\\n        output = FheOps(Precompiles.Fheos).verify(_toType, _ciphertextBytes);\\n        result = getValue(output);\\n    }\\n\\n    function cast(uint8 utype, uint256 ciphertext, uint8 toType) internal pure returns (uint256 result) {\\n        bytes memory output;\\n\\n        // Call the cast precompile.\\n        output = FheOps(Precompiles.Fheos).cast(utype, Common.toBytes(ciphertext), toType);\\n        result = getValue(output);\\n    }\\n\\n    function getValue(bytes memory a) internal pure returns (uint256 value) {\\n        assembly {\\n            value := mload(add(a, 0x20))\\n        }\\n    }\\n\\n    function trivialEncrypt(uint256 value, uint8 toType) internal pure returns (uint256 result) {\\n        bytes memory output;\\n\\n        // Call the trivialEncrypt precompile.\\n        output = FheOps(Precompiles.Fheos).trivialEncrypt(Common.toBytes(value), toType);\\n\\n        result = getValue(output);\\n    }\\n\\n    function select(uint8 utype, uint256 control, uint256 ifTrue, uint256 ifFalse) internal pure returns (uint256 result) {\\n        bytes memory output;\\n\\n        // Call the trivialEncrypt precompile.\\n        output = FheOps(Precompiles.Fheos).select(utype, Common.toBytes(control), Common.toBytes(ifTrue), Common.toBytes(ifFalse));\\n\\n        result = getValue(output);\\n    }\\n}\\n\\nlibrary FHE {\\n    euint8 public constant NIL8 = euint8.wrap(0);\\n    euint16 public constant NIL16 = euint16.wrap(0);\\n    euint32 public constant NIL32 = euint32.wrap(0);\\n\\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(ebool v) internal pure returns (bool) {\\n        return ebool.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint8 v) internal pure returns (bool) {\\n        return euint8.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint16 v) internal pure returns (bool) {\\n        return euint16.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint32 v) internal pure returns (bool) {\\n        return euint32.unwrap(v) != 0;\\n    }\\n    \\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint64 v) internal pure returns (bool) {\\n        return euint64.unwrap(v) != 0;\\n    }\\n    \\n        // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint128 v) internal pure returns (bool) {\\n        return euint128.unwrap(v) != 0;\\n    }\\n    \\n        // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint256 v) internal pure returns (bool) {\\n        return euint256.unwrap(v) != 0;\\n    }\\n\\n    function isInitialized(eaddress v) internal pure returns (bool) {\\n        return eaddress.unwrap(v) != 0;\\n    }\\n\\n    function getValue(bytes memory a) private pure returns (uint256 value) {\\n        assembly {\\n            value := mload(add(a, 0x20))\\n        }\\n    }\\n    \\n    function mathHelper(\\n        uint8 utype,\\n        uint256 lhs,\\n        uint256 rhs,\\n        function(uint8, bytes memory, bytes memory) external pure returns (bytes memory) impl\\n    ) internal pure returns (uint256 result) {\\n        bytes memory output;\\n        output = impl(utype, Common.toBytes(lhs), Common.toBytes(rhs));\\n        result = getValue(output);\\n    }\\n    \\n    /// @notice This functions performs the add operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function add(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the add operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function add(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the add operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function add(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the add operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function add(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the add operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function add(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice performs the sealoutput function on a ebool ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(ebool value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEbool(0);\\n        }\\n        uint256 unwrapped = ebool.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EBOOL_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint8 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint8 value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint8(0);\\n        }\\n        uint256 unwrapped = euint8.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT8_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint16 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint16 value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint16(0);\\n        }\\n        uint256 unwrapped = euint16.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT16_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint32 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint32 value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint32(0);\\n        }\\n        uint256 unwrapped = euint32.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT32_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint64 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint64 value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint64(0);\\n        }\\n        uint256 unwrapped = euint64.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT64_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint128 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint128 value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint128(0);\\n        }\\n        uint256 unwrapped = euint128.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT128_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint256 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint256 value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint256(0);\\n        }\\n        uint256 unwrapped = euint256.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT256_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a eaddress ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(eaddress value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEaddress(0);\\n        }\\n        uint256 unwrapped = eaddress.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EADDRESS_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(ebool input1) internal pure returns (bool) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EBOOL_TFHE, inputAsBytes);\\n        return Common.bigIntToBool(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint8 input1) internal pure returns (uint8) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT8_TFHE, inputAsBytes);\\n        return Common.bigIntToUint8(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint16 input1) internal pure returns (uint16) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT16_TFHE, inputAsBytes);\\n        return Common.bigIntToUint16(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint32 input1) internal pure returns (uint32) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT32_TFHE, inputAsBytes);\\n        return Common.bigIntToUint32(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint64 input1) internal pure returns (uint64) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT64_TFHE, inputAsBytes);\\n        return Common.bigIntToUint64(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint128 input1) internal pure returns (uint128) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT128_TFHE, inputAsBytes);\\n        return Common.bigIntToUint128(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint256 input1) internal pure returns (uint256) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint256(0);\\n        }\\n        uint256 unwrappedInput1 = euint256.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT256_TFHE, inputAsBytes);\\n        return Common.bigIntToUint256(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(eaddress input1) internal pure returns (address) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEaddress(0);\\n        }\\n        uint256 unwrappedInput1 = eaddress.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EADDRESS_TFHE, inputAsBytes);\\n        return Common.bigIntToAddress(result);\\n    }\\n    /// @notice This functions performs the lte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lte(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lte(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the sub operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function sub(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the sub operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function sub(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the sub operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function sub(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the sub operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function sub(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the sub operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function sub(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice This functions performs the mul operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function mul(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the mul operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function mul(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the mul operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function mul(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the mul operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function mul(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the lt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lt(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lt(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\\n        return ebool.wrap(result);\\n    }\\n\\n    function select(ebool input1, ebool input2, ebool input3) internal pure returns (ebool) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEbool(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEbool(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = ebool.unwrap(input2);\\n        uint256 unwrappedInput3 = ebool.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EBOOL_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return ebool.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint8 input2, euint8 input3) internal pure returns (euint8) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint8(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint8(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint8.unwrap(input2);\\n        uint256 unwrappedInput3 = euint8.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint8.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint16 input2, euint16 input3) internal pure returns (euint16) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint16(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint16(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint16.unwrap(input2);\\n        uint256 unwrappedInput3 = euint16.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint16.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint32 input2, euint32 input3) internal pure returns (euint32) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint32(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint32(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint32.unwrap(input2);\\n        uint256 unwrappedInput3 = euint32.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint32.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint64 input2, euint64 input3) internal pure returns (euint64) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint64(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint64(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint64.unwrap(input2);\\n        uint256 unwrappedInput3 = euint64.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint64.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint128 input2, euint128 input3) internal pure returns (euint128) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint128(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint128(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint128.unwrap(input2);\\n        uint256 unwrappedInput3 = euint128.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint128.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint256 input2, euint256 input3) internal pure returns (euint256) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint256(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint256(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint256.unwrap(input2);\\n        uint256 unwrappedInput3 = euint256.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT256_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint256.wrap(result);\\n    }\\n\\n    function select(ebool input1, eaddress input2, eaddress input3) internal pure returns (eaddress) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEaddress(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEaddress(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = eaddress.unwrap(input2);\\n        uint256 unwrappedInput3 = eaddress.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EADDRESS_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return eaddress.wrap(result);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(ebool input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EBOOL_TFHE, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint8 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT8_TFHE, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint16 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT16_TFHE, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint32 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT32_TFHE, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint64 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT64_TFHE, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint128 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT128_TFHE, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint256 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint256(0);\\n        }\\n        uint256 unwrappedInput1 = euint256.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT256_TFHE, inputAsBytes);\\n    }\\n    /// @notice This functions performs the div operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function div(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).div);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the div operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function div(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).div);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the div operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function div(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).div);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the gt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gt(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gt(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gte(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gte(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the rem operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function rem(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).rem);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the rem operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function rem(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).rem);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the rem operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function rem(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).rem);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint256 lhs, euint256 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint256(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint256(0);\\n        }\\n        uint256 unwrappedInput1 = euint256.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint256.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT256_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(eaddress lhs, eaddress rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEaddress(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEaddress(0);\\n        }\\n        uint256 unwrappedInput1 = eaddress.unwrap(lhs);\\n        uint256 unwrappedInput2 = eaddress.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EADDRESS_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint256 lhs, euint256 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint256(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint256(0);\\n        }\\n        uint256 unwrappedInput1 = euint256.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint256.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT256_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(eaddress lhs, eaddress rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEaddress(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEaddress(0);\\n        }\\n        uint256 unwrappedInput1 = eaddress.unwrap(lhs);\\n        uint256 unwrappedInput2 = eaddress.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EADDRESS_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the min operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function min(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the min operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function min(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the min operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function min(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the min operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function min(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the min operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function min(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice This functions performs the max operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function max(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the max operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function max(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the max operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function max(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the max operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function max(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the max operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function max(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice This functions performs the shl operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shl(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the shl operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shl(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the shl operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shl(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the shl operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shl(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the shl operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shl(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice This functions performs the shr operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shr(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the shr operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shr(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the shr operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shr(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the shr operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shr(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the shr operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shr(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\\n        return euint128.wrap(result);\\n    }\\n\\n    /// @notice Performs the \\\"not\\\" for the ebool type\\n    /// @dev Implemented by a workaround due to ebool being a euint8 type behind the scenes, therefore xor is needed to assure that not(true) = false and vise-versa\\n    /// @param value input ebool ciphertext\\n    /// @return Result of the not operation on `value` \\n    function not(ebool value) internal pure returns (ebool) {\\n        return xor(value, asEbool(true));\\n    }\\n    /// @notice Performs the not operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function not(euint8 input1) internal pure returns (euint8) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT8_TFHE, inputAsBytes);\\n        uint256 result = Impl.getValue(b);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice Performs the not operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function not(euint16 input1) internal pure returns (euint16) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT16_TFHE, inputAsBytes);\\n        uint256 result = Impl.getValue(b);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice Performs the not operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function not(euint32 input1) internal pure returns (euint32) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT32_TFHE, inputAsBytes);\\n        uint256 result = Impl.getValue(b);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice Performs the not operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function not(euint64 input1) internal pure returns (euint64) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT64_TFHE, inputAsBytes);\\n        uint256 result = Impl.getValue(b);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice Performs the not operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function not(euint128 input1) internal pure returns (euint128) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT128_TFHE, inputAsBytes);\\n        uint256 result = Impl.getValue(b);\\n        return euint128.wrap(result);\\n    }\\n\\n    // ********** TYPE CASTING ************* //\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an ebool\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEbool(inEbool memory value) internal pure returns (ebool) {\\n        return FHE.asEbool(value.data);\\n    }\\n    /// @notice Converts a ebool to an euint8\\n    function asEuint8(ebool value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EBOOL_TFHE, ebool.unwrap(value), Common.EUINT8_TFHE));\\n    }\\n    /// @notice Converts a ebool to an euint16\\n    function asEuint16(ebool value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EBOOL_TFHE, ebool.unwrap(value), Common.EUINT16_TFHE));\\n    }\\n    /// @notice Converts a ebool to an euint32\\n    function asEuint32(ebool value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EBOOL_TFHE, ebool.unwrap(value), Common.EUINT32_TFHE));\\n    }\\n    /// @notice Converts a ebool to an euint64\\n    function asEuint64(ebool value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.cast(Common.EBOOL_TFHE, ebool.unwrap(value), Common.EUINT64_TFHE));\\n    }\\n    /// @notice Converts a ebool to an euint128\\n    function asEuint128(ebool value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.cast(Common.EBOOL_TFHE, ebool.unwrap(value), Common.EUINT128_TFHE));\\n    }\\n    /// @notice Converts a ebool to an euint256\\n    function asEuint256(ebool value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.cast(Common.EBOOL_TFHE, ebool.unwrap(value), Common.EUINT256_TFHE));\\n    }\\n    /// @notice Converts a ebool to an eaddress\\n    function asEaddress(ebool value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.cast(Common.EBOOL_TFHE, ebool.unwrap(value), Common.EADDRESS_TFHE));\\n    }\\n    \\n    /// @notice Converts a euint8 to an ebool\\n    function asEbool(euint8 value) internal pure returns (ebool) {\\n        return ne(value, asEuint8(0));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint8\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint8(inEuint8 memory value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value.data);\\n    }\\n    /// @notice Converts a euint8 to an euint16\\n    function asEuint16(euint8 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EUINT8_TFHE, euint8.unwrap(value), Common.EUINT16_TFHE));\\n    }\\n    /// @notice Converts a euint8 to an euint32\\n    function asEuint32(euint8 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EUINT8_TFHE, euint8.unwrap(value), Common.EUINT32_TFHE));\\n    }\\n    /// @notice Converts a euint8 to an euint64\\n    function asEuint64(euint8 value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.cast(Common.EUINT8_TFHE, euint8.unwrap(value), Common.EUINT64_TFHE));\\n    }\\n    /// @notice Converts a euint8 to an euint128\\n    function asEuint128(euint8 value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.cast(Common.EUINT8_TFHE, euint8.unwrap(value), Common.EUINT128_TFHE));\\n    }\\n    /// @notice Converts a euint8 to an euint256\\n    function asEuint256(euint8 value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.cast(Common.EUINT8_TFHE, euint8.unwrap(value), Common.EUINT256_TFHE));\\n    }\\n    /// @notice Converts a euint8 to an eaddress\\n    function asEaddress(euint8 value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.cast(Common.EUINT8_TFHE, euint8.unwrap(value), Common.EADDRESS_TFHE));\\n    }\\n    \\n    /// @notice Converts a euint16 to an ebool\\n    function asEbool(euint16 value) internal pure returns (ebool) {\\n        return ne(value, asEuint16(0));\\n    }\\n    /// @notice Converts a euint16 to an euint8\\n    function asEuint8(euint16 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EUINT16_TFHE, euint16.unwrap(value), Common.EUINT8_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint16\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint16(inEuint16 memory value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value.data);\\n    }\\n    /// @notice Converts a euint16 to an euint32\\n    function asEuint32(euint16 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EUINT16_TFHE, euint16.unwrap(value), Common.EUINT32_TFHE));\\n    }\\n    /// @notice Converts a euint16 to an euint64\\n    function asEuint64(euint16 value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.cast(Common.EUINT16_TFHE, euint16.unwrap(value), Common.EUINT64_TFHE));\\n    }\\n    /// @notice Converts a euint16 to an euint128\\n    function asEuint128(euint16 value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.cast(Common.EUINT16_TFHE, euint16.unwrap(value), Common.EUINT128_TFHE));\\n    }\\n    /// @notice Converts a euint16 to an euint256\\n    function asEuint256(euint16 value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.cast(Common.EUINT16_TFHE, euint16.unwrap(value), Common.EUINT256_TFHE));\\n    }\\n    /// @notice Converts a euint16 to an eaddress\\n    function asEaddress(euint16 value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.cast(Common.EUINT16_TFHE, euint16.unwrap(value), Common.EADDRESS_TFHE));\\n    }\\n    \\n    /// @notice Converts a euint32 to an ebool\\n    function asEbool(euint32 value) internal pure returns (ebool) {\\n        return ne(value, asEuint32(0));\\n    }\\n    /// @notice Converts a euint32 to an euint8\\n    function asEuint8(euint32 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EUINT32_TFHE, euint32.unwrap(value), Common.EUINT8_TFHE));\\n    }\\n    /// @notice Converts a euint32 to an euint16\\n    function asEuint16(euint32 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EUINT32_TFHE, euint32.unwrap(value), Common.EUINT16_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint32\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint32(inEuint32 memory value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value.data);\\n    }\\n    /// @notice Converts a euint32 to an euint64\\n    function asEuint64(euint32 value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.cast(Common.EUINT32_TFHE, euint32.unwrap(value), Common.EUINT64_TFHE));\\n    }\\n    /// @notice Converts a euint32 to an euint128\\n    function asEuint128(euint32 value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.cast(Common.EUINT32_TFHE, euint32.unwrap(value), Common.EUINT128_TFHE));\\n    }\\n    /// @notice Converts a euint32 to an euint256\\n    function asEuint256(euint32 value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.cast(Common.EUINT32_TFHE, euint32.unwrap(value), Common.EUINT256_TFHE));\\n    }\\n    /// @notice Converts a euint32 to an eaddress\\n    function asEaddress(euint32 value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.cast(Common.EUINT32_TFHE, euint32.unwrap(value), Common.EADDRESS_TFHE));\\n    }\\n    \\n    /// @notice Converts a euint64 to an ebool\\n    function asEbool(euint64 value) internal pure returns (ebool) {\\n        return ne(value, asEuint64(0));\\n    }\\n    /// @notice Converts a euint64 to an euint8\\n    function asEuint8(euint64 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EUINT64_TFHE, euint64.unwrap(value), Common.EUINT8_TFHE));\\n    }\\n    /// @notice Converts a euint64 to an euint16\\n    function asEuint16(euint64 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EUINT64_TFHE, euint64.unwrap(value), Common.EUINT16_TFHE));\\n    }\\n    /// @notice Converts a euint64 to an euint32\\n    function asEuint32(euint64 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EUINT64_TFHE, euint64.unwrap(value), Common.EUINT32_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint64\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint64(inEuint64 memory value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value.data);\\n    }\\n    /// @notice Converts a euint64 to an euint128\\n    function asEuint128(euint64 value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.cast(Common.EUINT64_TFHE, euint64.unwrap(value), Common.EUINT128_TFHE));\\n    }\\n    /// @notice Converts a euint64 to an euint256\\n    function asEuint256(euint64 value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.cast(Common.EUINT64_TFHE, euint64.unwrap(value), Common.EUINT256_TFHE));\\n    }\\n    /// @notice Converts a euint64 to an eaddress\\n    function asEaddress(euint64 value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.cast(Common.EUINT64_TFHE, euint64.unwrap(value), Common.EADDRESS_TFHE));\\n    }\\n    \\n    /// @notice Converts a euint128 to an ebool\\n    function asEbool(euint128 value) internal pure returns (ebool) {\\n        return ne(value, asEuint128(0));\\n    }\\n    /// @notice Converts a euint128 to an euint8\\n    function asEuint8(euint128 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EUINT128_TFHE, euint128.unwrap(value), Common.EUINT8_TFHE));\\n    }\\n    /// @notice Converts a euint128 to an euint16\\n    function asEuint16(euint128 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EUINT128_TFHE, euint128.unwrap(value), Common.EUINT16_TFHE));\\n    }\\n    /// @notice Converts a euint128 to an euint32\\n    function asEuint32(euint128 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EUINT128_TFHE, euint128.unwrap(value), Common.EUINT32_TFHE));\\n    }\\n    /// @notice Converts a euint128 to an euint64\\n    function asEuint64(euint128 value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.cast(Common.EUINT128_TFHE, euint128.unwrap(value), Common.EUINT64_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint128\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint128(inEuint128 memory value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value.data);\\n    }\\n    /// @notice Converts a euint128 to an euint256\\n    function asEuint256(euint128 value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.cast(Common.EUINT128_TFHE, euint128.unwrap(value), Common.EUINT256_TFHE));\\n    }\\n    /// @notice Converts a euint128 to an eaddress\\n    function asEaddress(euint128 value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.cast(Common.EUINT128_TFHE, euint128.unwrap(value), Common.EADDRESS_TFHE));\\n    }\\n    \\n    /// @notice Converts a euint256 to an ebool\\n    function asEbool(euint256 value) internal pure returns (ebool) {\\n        return ne(value, asEuint256(0));\\n    }\\n    /// @notice Converts a euint256 to an euint8\\n    function asEuint8(euint256 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EUINT256_TFHE, euint256.unwrap(value), Common.EUINT8_TFHE));\\n    }\\n    /// @notice Converts a euint256 to an euint16\\n    function asEuint16(euint256 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EUINT256_TFHE, euint256.unwrap(value), Common.EUINT16_TFHE));\\n    }\\n    /// @notice Converts a euint256 to an euint32\\n    function asEuint32(euint256 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EUINT256_TFHE, euint256.unwrap(value), Common.EUINT32_TFHE));\\n    }\\n    /// @notice Converts a euint256 to an euint64\\n    function asEuint64(euint256 value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.cast(Common.EUINT256_TFHE, euint256.unwrap(value), Common.EUINT64_TFHE));\\n    }\\n    /// @notice Converts a euint256 to an euint128\\n    function asEuint128(euint256 value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.cast(Common.EUINT256_TFHE, euint256.unwrap(value), Common.EUINT128_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint256\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint256(inEuint256 memory value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value.data);\\n    }\\n    /// @notice Converts a euint256 to an eaddress\\n    function asEaddress(euint256 value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.cast(Common.EUINT256_TFHE, euint256.unwrap(value), Common.EADDRESS_TFHE));\\n    }\\n    \\n    /// @notice Converts a eaddress to an ebool\\n    function asEbool(eaddress value) internal pure returns (ebool) {\\n        return ne(value, asEaddress(0));\\n    }\\n    /// @notice Converts a eaddress to an euint8\\n    function asEuint8(eaddress value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EADDRESS_TFHE, eaddress.unwrap(value), Common.EUINT8_TFHE));\\n    }\\n    /// @notice Converts a eaddress to an euint16\\n    function asEuint16(eaddress value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EADDRESS_TFHE, eaddress.unwrap(value), Common.EUINT16_TFHE));\\n    }\\n    /// @notice Converts a eaddress to an euint32\\n    function asEuint32(eaddress value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EADDRESS_TFHE, eaddress.unwrap(value), Common.EUINT32_TFHE));\\n    }\\n    /// @notice Converts a eaddress to an euint64\\n    function asEuint64(eaddress value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.cast(Common.EADDRESS_TFHE, eaddress.unwrap(value), Common.EUINT64_TFHE));\\n    }\\n    /// @notice Converts a eaddress to an euint128\\n    function asEuint128(eaddress value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.cast(Common.EADDRESS_TFHE, eaddress.unwrap(value), Common.EUINT128_TFHE));\\n    }\\n    /// @notice Converts a eaddress to an euint256\\n    function asEuint256(eaddress value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.cast(Common.EADDRESS_TFHE, eaddress.unwrap(value), Common.EUINT256_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an eaddress\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEaddress(inEaddress memory value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value.data);\\n    }\\n    /// @notice Converts a uint256 to an ebool\\n    function asEbool(uint256 value) internal pure returns (ebool) {\\n        return ebool.wrap(Impl.trivialEncrypt(value, Common.EBOOL_TFHE));\\n    }\\n    /// @notice Converts a uint256 to an euint8\\n    function asEuint8(uint256 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.trivialEncrypt(value, Common.EUINT8_TFHE));\\n    }\\n    /// @notice Converts a uint256 to an euint16\\n    function asEuint16(uint256 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.trivialEncrypt(value, Common.EUINT16_TFHE));\\n    }\\n    /// @notice Converts a uint256 to an euint32\\n    function asEuint32(uint256 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.trivialEncrypt(value, Common.EUINT32_TFHE));\\n    }\\n    /// @notice Converts a uint256 to an euint64\\n    function asEuint64(uint256 value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.trivialEncrypt(value, Common.EUINT64_TFHE));\\n    }\\n    /// @notice Converts a uint256 to an euint128\\n    function asEuint128(uint256 value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.trivialEncrypt(value, Common.EUINT128_TFHE));\\n    }\\n    /// @notice Converts a uint256 to an euint256\\n    function asEuint256(uint256 value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.trivialEncrypt(value, Common.EUINT256_TFHE));\\n    }\\n    /// @notice Converts a uint256 to an eaddress\\n    function asEaddress(uint256 value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.trivialEncrypt(value, Common.EADDRESS_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an ebool\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEbool(bytes memory value) internal pure returns (ebool) {\\n        return ebool.wrap(Impl.verify(value, Common.EBOOL_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint8\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint8(bytes memory value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.verify(value, Common.EUINT8_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint16\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint16(bytes memory value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.verify(value, Common.EUINT16_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint32\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint32(bytes memory value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.verify(value, Common.EUINT32_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint64\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint64(bytes memory value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.verify(value, Common.EUINT64_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint128\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint128(bytes memory value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.verify(value, Common.EUINT128_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint256\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint256(bytes memory value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.verify(value, Common.EUINT256_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an eaddress\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEaddress(bytes memory value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.verify(value, Common.EADDRESS_TFHE));\\n    }\\n    /// @notice Converts a address to an eaddress\\n    /// Allows for a better user experience when working with eaddresses\\n    function asEaddress(address value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.trivialEncrypt(uint256(uint160(value)), Common.EADDRESS_TFHE));\\n    }\\n    /// @notice Converts a plaintext boolean value to a ciphertext ebool\\n    /// @dev Privacy: The input value is public, therefore the ciphertext should be considered public and should be used\\n    ///only for mathematical operations, not to represent data that should be private\\n    /// @return A ciphertext representation of the input \\n    function asEbool(bool value) internal pure returns (ebool) {\\n        uint256 sVal = 0;\\n        if (value) {\\n            sVal = 1;\\n        }\\n\\n        return asEbool(sVal);\\n    }\\n}\\n\\n// ********** OPERATOR OVERLOADING ************* //\\n\\nusing {operatorAddEuint8 as +} for euint8 global;\\n/// @notice Performs the add operation\\nfunction operatorAddEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.add(lhs, rhs);\\n}\\n\\nusing {operatorAddEuint16 as +} for euint16 global;\\n/// @notice Performs the add operation\\nfunction operatorAddEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.add(lhs, rhs);\\n}\\n\\nusing {operatorAddEuint32 as +} for euint32 global;\\n/// @notice Performs the add operation\\nfunction operatorAddEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.add(lhs, rhs);\\n}\\n\\nusing {operatorAddEuint64 as +} for euint64 global;\\n/// @notice Performs the add operation\\nfunction operatorAddEuint64(euint64 lhs, euint64 rhs) pure returns (euint64) {\\n    return FHE.add(lhs, rhs);\\n}\\n\\nusing {operatorAddEuint128 as +} for euint128 global;\\n/// @notice Performs the add operation\\nfunction operatorAddEuint128(euint128 lhs, euint128 rhs) pure returns (euint128) {\\n    return FHE.add(lhs, rhs);\\n}\\n\\nusing {operatorSubEuint8 as -} for euint8 global;\\n/// @notice Performs the sub operation\\nfunction operatorSubEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.sub(lhs, rhs);\\n}\\n\\nusing {operatorSubEuint16 as -} for euint16 global;\\n/// @notice Performs the sub operation\\nfunction operatorSubEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.sub(lhs, rhs);\\n}\\n\\nusing {operatorSubEuint32 as -} for euint32 global;\\n/// @notice Performs the sub operation\\nfunction operatorSubEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.sub(lhs, rhs);\\n}\\n\\nusing {operatorSubEuint64 as -} for euint64 global;\\n/// @notice Performs the sub operation\\nfunction operatorSubEuint64(euint64 lhs, euint64 rhs) pure returns (euint64) {\\n    return FHE.sub(lhs, rhs);\\n}\\n\\nusing {operatorSubEuint128 as -} for euint128 global;\\n/// @notice Performs the sub operation\\nfunction operatorSubEuint128(euint128 lhs, euint128 rhs) pure returns (euint128) {\\n    return FHE.sub(lhs, rhs);\\n}\\n\\nusing {operatorMulEuint8 as *} for euint8 global;\\n/// @notice Performs the mul operation\\nfunction operatorMulEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.mul(lhs, rhs);\\n}\\n\\nusing {operatorMulEuint16 as *} for euint16 global;\\n/// @notice Performs the mul operation\\nfunction operatorMulEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.mul(lhs, rhs);\\n}\\n\\nusing {operatorMulEuint32 as *} for euint32 global;\\n/// @notice Performs the mul operation\\nfunction operatorMulEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.mul(lhs, rhs);\\n}\\n\\nusing {operatorMulEuint64 as *} for euint64 global;\\n/// @notice Performs the mul operation\\nfunction operatorMulEuint64(euint64 lhs, euint64 rhs) pure returns (euint64) {\\n    return FHE.mul(lhs, rhs);\\n}\\n\\nusing {operatorDivEuint8 as /} for euint8 global;\\n/// @notice Performs the div operation\\nfunction operatorDivEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.div(lhs, rhs);\\n}\\n\\nusing {operatorDivEuint16 as /} for euint16 global;\\n/// @notice Performs the div operation\\nfunction operatorDivEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.div(lhs, rhs);\\n}\\n\\nusing {operatorDivEuint32 as /} for euint32 global;\\n/// @notice Performs the div operation\\nfunction operatorDivEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.div(lhs, rhs);\\n}\\n\\nusing {operatorOrEbool as |} for ebool global;\\n/// @notice Performs the or operation\\nfunction operatorOrEbool(ebool lhs, ebool rhs) pure returns (ebool) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorOrEuint8 as |} for euint8 global;\\n/// @notice Performs the or operation\\nfunction operatorOrEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorOrEuint16 as |} for euint16 global;\\n/// @notice Performs the or operation\\nfunction operatorOrEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorOrEuint32 as |} for euint32 global;\\n/// @notice Performs the or operation\\nfunction operatorOrEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorOrEuint64 as |} for euint64 global;\\n/// @notice Performs the or operation\\nfunction operatorOrEuint64(euint64 lhs, euint64 rhs) pure returns (euint64) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorOrEuint128 as |} for euint128 global;\\n/// @notice Performs the or operation\\nfunction operatorOrEuint128(euint128 lhs, euint128 rhs) pure returns (euint128) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorAndEbool as &} for ebool global;\\n/// @notice Performs the and operation\\nfunction operatorAndEbool(ebool lhs, ebool rhs) pure returns (ebool) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorAndEuint8 as &} for euint8 global;\\n/// @notice Performs the and operation\\nfunction operatorAndEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorAndEuint16 as &} for euint16 global;\\n/// @notice Performs the and operation\\nfunction operatorAndEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorAndEuint32 as &} for euint32 global;\\n/// @notice Performs the and operation\\nfunction operatorAndEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorAndEuint64 as &} for euint64 global;\\n/// @notice Performs the and operation\\nfunction operatorAndEuint64(euint64 lhs, euint64 rhs) pure returns (euint64) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorAndEuint128 as &} for euint128 global;\\n/// @notice Performs the and operation\\nfunction operatorAndEuint128(euint128 lhs, euint128 rhs) pure returns (euint128) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorXorEbool as ^} for ebool global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEbool(ebool lhs, ebool rhs) pure returns (ebool) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorXorEuint8 as ^} for euint8 global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorXorEuint16 as ^} for euint16 global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorXorEuint32 as ^} for euint32 global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorXorEuint64 as ^} for euint64 global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEuint64(euint64 lhs, euint64 rhs) pure returns (euint64) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorXorEuint128 as ^} for euint128 global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEuint128(euint128 lhs, euint128 rhs) pure returns (euint128) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorRemEuint8 as %} for euint8 global;\\n/// @notice Performs the rem operation\\nfunction operatorRemEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.rem(lhs, rhs);\\n}\\n\\nusing {operatorRemEuint16 as %} for euint16 global;\\n/// @notice Performs the rem operation\\nfunction operatorRemEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.rem(lhs, rhs);\\n}\\n\\nusing {operatorRemEuint32 as %} for euint32 global;\\n/// @notice Performs the rem operation\\nfunction operatorRemEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.rem(lhs, rhs);\\n}\\n\\n// ********** BINDING DEFS ************* //\\n\\nusing BindingsEbool for ebool global;\\nlibrary BindingsEbool {\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the eq\\n    function eq(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the ne\\n    function ne(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the and\\n    function and(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the or\\n    function or(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the xor\\n    function xor(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    function toU8(ebool value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(ebool value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(ebool value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function toU64(ebool value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value);\\n    }\\n    function toU128(ebool value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value);\\n    }\\n    function toU256(ebool value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value);\\n    }\\n    function toEaddress(ebool value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value);\\n    }\\n    function seal(ebool value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(ebool value) internal pure returns (bool) {\\n        return FHE.decrypt(value);\\n    }\\n}\\n\\nusing BindingsEuint8 for euint8 global;\\nlibrary BindingsEuint8 {\\n    \\n    /// @notice Performs the add operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the add\\n    function add(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.add(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the mul operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the mul\\n    function mul(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.mul(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the div operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the div\\n    function div(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.div(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the sub operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the sub\\n    function sub(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.sub(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the eq\\n    function eq(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the ne\\n    function ne(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the and\\n    function and(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the or\\n    function or(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the xor\\n    function xor(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the gt\\n    function gt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.gt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the gte\\n    function gte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.gte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the lt\\n    function lt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.lt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the lte\\n    function lte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.lte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the rem operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the rem\\n    function rem(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.rem(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the max operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the max\\n    function max(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.max(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the min operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the min\\n    function min(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.min(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shl operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the shl\\n    function shl(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.shl(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shr operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the shr\\n    function shr(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.shr(lhs, rhs);\\n    }\\n    function toBool(euint8 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU16(euint8 value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(euint8 value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function toU64(euint8 value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value);\\n    }\\n    function toU128(euint8 value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value);\\n    }\\n    function toU256(euint8 value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value);\\n    }\\n    function toEaddress(euint8 value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value);\\n    }\\n    function seal(euint8 value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(euint8 value) internal pure returns (uint8) {\\n        return FHE.decrypt(value);\\n    }\\n}\\n\\nusing BindingsEuint16 for euint16 global;\\nlibrary BindingsEuint16 {\\n    \\n    /// @notice Performs the add operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the add\\n    function add(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.add(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the mul operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the mul\\n    function mul(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.mul(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the div operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the div\\n    function div(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.div(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the sub operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the sub\\n    function sub(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.sub(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the eq\\n    function eq(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the ne\\n    function ne(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the and\\n    function and(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the or\\n    function or(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the xor\\n    function xor(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the gt\\n    function gt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.gt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the gte\\n    function gte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.gte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the lt\\n    function lt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.lt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the lte\\n    function lte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.lte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the rem operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the rem\\n    function rem(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.rem(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the max operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the max\\n    function max(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.max(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the min operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the min\\n    function min(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.min(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shl operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the shl\\n    function shl(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.shl(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shr operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the shr\\n    function shr(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.shr(lhs, rhs);\\n    }\\n    function toBool(euint16 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(euint16 value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU32(euint16 value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function toU64(euint16 value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value);\\n    }\\n    function toU128(euint16 value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value);\\n    }\\n    function toU256(euint16 value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value);\\n    }\\n    function toEaddress(euint16 value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value);\\n    }\\n    function seal(euint16 value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(euint16 value) internal pure returns (uint16) {\\n        return FHE.decrypt(value);\\n    }\\n}\\n\\nusing BindingsEuint32 for euint32 global;\\nlibrary BindingsEuint32 {\\n    \\n    /// @notice Performs the add operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the add\\n    function add(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.add(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the mul operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the mul\\n    function mul(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.mul(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the div operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the div\\n    function div(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.div(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the sub operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the sub\\n    function sub(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.sub(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the eq\\n    function eq(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the ne\\n    function ne(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the and\\n    function and(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the or\\n    function or(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the xor\\n    function xor(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the gt\\n    function gt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.gt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the gte\\n    function gte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.gte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the lt\\n    function lt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.lt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the lte\\n    function lte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.lte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the rem operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the rem\\n    function rem(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.rem(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the max operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the max\\n    function max(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.max(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the min operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the min\\n    function min(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.min(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shl operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the shl\\n    function shl(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.shl(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shr operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the shr\\n    function shr(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.shr(lhs, rhs);\\n    }\\n    function toBool(euint32 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(euint32 value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(euint32 value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU64(euint32 value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value);\\n    }\\n    function toU128(euint32 value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value);\\n    }\\n    function toU256(euint32 value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value);\\n    }\\n    function toEaddress(euint32 value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value);\\n    }\\n    function seal(euint32 value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(euint32 value) internal pure returns (uint32) {\\n        return FHE.decrypt(value);\\n    }\\n}\\n\\nusing BindingsEuint64 for euint64 global;\\nlibrary BindingsEuint64 {\\n    \\n    /// @notice Performs the add operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the add\\n    function add(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.add(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the mul operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the mul\\n    function mul(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.mul(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the sub operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the sub\\n    function sub(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.sub(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the eq\\n    function eq(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the ne\\n    function ne(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the and\\n    function and(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the or\\n    function or(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the xor\\n    function xor(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the gt\\n    function gt(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        return FHE.gt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the gte\\n    function gte(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        return FHE.gte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the lt\\n    function lt(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        return FHE.lt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the lte\\n    function lte(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        return FHE.lte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the max operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the max\\n    function max(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.max(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the min operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the min\\n    function min(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.min(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shl operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the shl\\n    function shl(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.shl(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shr operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the shr\\n    function shr(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.shr(lhs, rhs);\\n    }\\n    function toBool(euint64 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(euint64 value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(euint64 value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(euint64 value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function toU128(euint64 value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value);\\n    }\\n    function toU256(euint64 value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value);\\n    }\\n    function toEaddress(euint64 value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value);\\n    }\\n    function seal(euint64 value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(euint64 value) internal pure returns (uint64) {\\n        return FHE.decrypt(value);\\n    }\\n}\\n\\nusing BindingsEuint128 for euint128 global;\\nlibrary BindingsEuint128 {\\n    \\n    /// @notice Performs the add operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the add\\n    function add(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.add(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the sub operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the sub\\n    function sub(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.sub(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the eq\\n    function eq(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the ne\\n    function ne(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the and\\n    function and(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the or\\n    function or(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the xor\\n    function xor(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the gt\\n    function gt(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        return FHE.gt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the gte\\n    function gte(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        return FHE.gte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the lt\\n    function lt(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        return FHE.lt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the lte\\n    function lte(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        return FHE.lte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the max operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the max\\n    function max(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.max(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the min operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the min\\n    function min(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.min(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shl operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the shl\\n    function shl(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.shl(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shr operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the shr\\n    function shr(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.shr(lhs, rhs);\\n    }\\n    function toBool(euint128 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(euint128 value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(euint128 value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(euint128 value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function toU64(euint128 value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value);\\n    }\\n    function toU256(euint128 value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value);\\n    }\\n    function toEaddress(euint128 value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value);\\n    }\\n    function seal(euint128 value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(euint128 value) internal pure returns (uint128) {\\n        return FHE.decrypt(value);\\n    }\\n}\\n\\nusing BindingsEuint256 for euint256 global;\\nlibrary BindingsEuint256 {\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint256\\n    /// @return the result of the eq\\n    function eq(euint256 lhs, euint256 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint256\\n    /// @return the result of the ne\\n    function ne(euint256 lhs, euint256 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    function toBool(euint256 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(euint256 value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(euint256 value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(euint256 value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function toU64(euint256 value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value);\\n    }\\n    function toU128(euint256 value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value);\\n    }\\n    function toEaddress(euint256 value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value);\\n    }\\n    function seal(euint256 value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(euint256 value) internal pure returns (uint256) {\\n        return FHE.decrypt(value);\\n    }\\n}\\n\\nusing BindingsEaddress for eaddress global;\\nlibrary BindingsEaddress {\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type eaddress\\n    /// @return the result of the eq\\n    function eq(eaddress lhs, eaddress rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type eaddress\\n    /// @return the result of the ne\\n    function ne(eaddress lhs, eaddress rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    function toBool(eaddress value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(eaddress value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(eaddress value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(eaddress value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function toU64(eaddress value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value);\\n    }\\n    function toU128(eaddress value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value);\\n    }\\n    function toU256(eaddress value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value);\\n    }\\n    function seal(eaddress value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(eaddress value) internal pure returns (address) {\\n        return FHE.decrypt(value);\\n    }\\n}\",\"keccak256\":\"0x1ffd2f9f5c64d58f600d54eba6c74d5c158455dd3e1eb827f1e745b1c81218a3\",\"license\":\"BSD-3-Clause-Clear\"},\"@fhenixprotocol/contracts/FheOS.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\n// solhint-disable one-contract-per-file\\npragma solidity >=0.8.13 <0.9.0;\\n\\nlibrary Precompiles {\\n    //solhint-disable const-name-snakecase\\n    address public constant Fheos = address(128);\\n}\\n\\ninterface FheOps {\\n    function log(string memory s) external pure;\\n    function add(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function verify(uint8 utype, bytes memory input) external pure returns (bytes memory);\\n    function sealOutput(uint8 utype, bytes memory ctHash, bytes memory pk) external pure returns (string memory);\\n    function decrypt(uint8 utype, bytes memory input) external pure returns (uint256);\\n    function lte(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function sub(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function mul(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function lt(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function select(uint8 utype, bytes memory controlHash, bytes memory ifTrueHash, bytes memory ifFalseHash) external pure returns (bytes memory);\\n    function req(uint8 utype, bytes memory input) external pure returns (bytes memory);\\n    function cast(uint8 utype, bytes memory input, uint8 toType) external pure returns (bytes memory);\\n    function trivialEncrypt(bytes memory input, uint8 toType) external pure returns (bytes memory);\\n    function div(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function gt(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function gte(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function rem(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function and(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function or(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function xor(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function eq(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function ne(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function min(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function max(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function shl(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function shr(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function not(uint8 utype, bytes memory value) external pure returns (bytes memory);\\n    function getNetworkPublicKey() external pure returns (bytes memory);\\n}\",\"keccak256\":\"0xc704013bec920b763d309d02f6c459acb16326b056bea878ee2130792be2fdac\",\"license\":\"BSD-3-Clause-Clear\"},\"@fhenixprotocol/contracts/access/Permissioned.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity >=0.8.19 <0.9.0;\\n\\nimport { ECDSA } from \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport { EIP712 } from \\\"@openzeppelin/contracts/utils/cryptography/EIP712.sol\\\";\\n\\n/// @title Permissioned Access Control Contract\\n/// @notice Abstract contract that provides EIP-712 based signature verification for access control\\n/// @dev This contract should be inherited by other contracts to provide EIP-712 signature validated access control\\nabstract contract Permissioned is EIP712 {\\n    /// @notice Emitted when the signer is not the message sender\\n    error SignerNotMessageSender();\\n\\n    /// @notice Emitted when the signer is not the specified owner\\n    error SignerNotOwner();\\n\\n    /// @dev Constructor that initializes EIP712 domain separator with a name and version\\n    /// solhint-disable-next-line func-visibility, no-empty-blocks\\n    constructor() EIP712(\\\"Fhenix Permission\\\", \\\"1.0\\\") {} \\n\\n    /// @notice Modifier that requires the provided signature to be signed by the message sender\\n    /// @param permission Data structure containing the public key and the signature to be verified\\n    modifier onlySender(Permission memory permission) {\\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n            keccak256(\\\"Permissioned(bytes32 publicKey)\\\"),\\n            permission.publicKey\\n        )));\\n        address signer = ECDSA.recover(digest, permission.signature);\\n        if (signer != msg.sender)\\n            revert SignerNotMessageSender();\\n        _;\\n    }\\n\\n    /// @notice Modifier that requires the provided signature to be signed by a specific owner address\\n    /// @param permission Data structure containing the public key and the signature to be verified\\n    /// @param owner The expected owner of the public key to match against the recovered signer\\n    modifier onlyPermitted(Permission memory permission, address owner) {\\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n            keccak256(\\\"Permissioned(bytes32 publicKey)\\\"),\\n            permission.publicKey\\n        )));\\n        address signer = ECDSA.recover(digest, permission.signature);\\n        if (signer != owner)\\n            revert SignerNotOwner();\\n        _;\\n    }\\n}\\n\\n/// @title Struct for holding signature information\\n/// @notice Used to pass both the public key and signature data within transactions\\n/// @dev Should be used with Signature-based modifiers for access control\\nstruct Permission {\\n    bytes32 publicKey;\\n    bytes signature;\\n}\\n\",\"keccak256\":\"0xfff6f7f1a33a83c578c93464dd936e6bda2ca619cfe298a0c5d76d6bb79a25f7\",\"license\":\"BSD-3-Clause-Clear\"},\"@openzeppelin/contracts/interfaces/IERC5267.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\\n\\npragma solidity ^0.8.20;\\n\\ninterface IERC5267 {\\n    /**\\n     * @dev MAY be emitted to signal that the domain could have changed.\\n     */\\n    event EIP712DomainChanged();\\n\\n    /**\\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\\n     * signature.\\n     */\\n    function eip712Domain()\\n        external\\n        view\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        );\\n}\\n\",\"keccak256\":\"0x92aa1df62dc3d33f1656d63bede0923e0df0b706ad4137c8b10b0a8fe549fd92\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/ShortStrings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {StorageSlot} from \\\"./StorageSlot.sol\\\";\\n\\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\\n// | length  | 0x                                                              BB |\\ntype ShortString is bytes32;\\n\\n/**\\n * @dev This library provides functions to convert short memory strings\\n * into a `ShortString` type that can be used as an immutable variable.\\n *\\n * Strings of arbitrary length can be optimized using this library if\\n * they are short enough (up to 31 bytes) by packing them with their\\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\\n * fallback mechanism can be used for every other case.\\n *\\n * Usage example:\\n *\\n * ```solidity\\n * contract Named {\\n *     using ShortStrings for *;\\n *\\n *     ShortString private immutable _name;\\n *     string private _nameFallback;\\n *\\n *     constructor(string memory contractName) {\\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\\n *     }\\n *\\n *     function name() external view returns (string memory) {\\n *         return _name.toStringWithFallback(_nameFallback);\\n *     }\\n * }\\n * ```\\n */\\nlibrary ShortStrings {\\n    // Used as an identifier for strings longer than 31 bytes.\\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\\n\\n    error StringTooLong(string str);\\n    error InvalidShortString();\\n\\n    /**\\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\\n     *\\n     * This will trigger a `StringTooLong` error is the input string is too long.\\n     */\\n    function toShortString(string memory str) internal pure returns (ShortString) {\\n        bytes memory bstr = bytes(str);\\n        if (bstr.length > 31) {\\n            revert StringTooLong(str);\\n        }\\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\\n    }\\n\\n    /**\\n     * @dev Decode a `ShortString` back to a \\\"normal\\\" string.\\n     */\\n    function toString(ShortString sstr) internal pure returns (string memory) {\\n        uint256 len = byteLength(sstr);\\n        // using `new string(len)` would work locally but is not memory safe.\\n        string memory str = new string(32);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(str, len)\\n            mstore(add(str, 0x20), sstr)\\n        }\\n        return str;\\n    }\\n\\n    /**\\n     * @dev Return the length of a `ShortString`.\\n     */\\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\\n        if (result > 31) {\\n            revert InvalidShortString();\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\\n     */\\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\\n        if (bytes(value).length < 32) {\\n            return toShortString(value);\\n        } else {\\n            StorageSlot.getStringSlot(store).value = value;\\n            return ShortString.wrap(FALLBACK_SENTINEL);\\n        }\\n    }\\n\\n    /**\\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\\n     */\\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\\n            return toString(value);\\n        } else {\\n            return store;\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\\n     * {setWithFallback}.\\n     *\\n     * WARNING: This will return the \\\"byte length\\\" of the string. This may not reflect the actual length in terms of\\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\\n     */\\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\\n            return byteLength(value);\\n        } else {\\n            return bytes(store).length;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x18a7171df639a934592915a520ecb97c5bbc9675a1105607aac8a94e72bf62c6\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x32ba59b4b7299237c8ba56319110989d7978a039faf754793064e967e5894418\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x55f102ea785d8399c0e58d1108e2d289506dde18abc6db1b7f68c1f9f9bc5792\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS\\n    }\\n\\n    /**\\n     * @dev The signature derives the `address(0)`.\\n     */\\n    error ECDSAInvalidSignature();\\n\\n    /**\\n     * @dev The signature has an invalid length.\\n     */\\n    error ECDSAInvalidSignatureLength(uint256 length);\\n\\n    /**\\n     * @dev The signature has an S value that is in the upper half order.\\n     */\\n    error ECDSAInvalidSignatureS(bytes32 s);\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\\n     * and a bytes32 providing additional information about the error.\\n     *\\n     * If no error is returned, then the address can be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\\n        unchecked {\\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\\n            return tryRecover(hash, v, r, s);\\n        }\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError, bytes32) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS, s);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\\n        }\\n\\n        return (signer, RecoverError.NoError, bytes32(0));\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\\n     */\\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert ECDSAInvalidSignature();\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert ECDSAInvalidSignatureS(errorArg);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xeed0a08b0b091f528356cbc7245891a4c748682d4f6a18055e8e6ca77d12a6cf\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/EIP712.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {MessageHashUtils} from \\\"./MessageHashUtils.sol\\\";\\nimport {ShortStrings, ShortString} from \\\"../ShortStrings.sol\\\";\\nimport {IERC5267} from \\\"../../interfaces/IERC5267.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\\n *\\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n */\\nabstract contract EIP712 is IERC5267 {\\n    using ShortStrings for *;\\n\\n    bytes32 private constant TYPE_HASH =\\n        keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _cachedDomainSeparator;\\n    uint256 private immutable _cachedChainId;\\n    address private immutable _cachedThis;\\n\\n    bytes32 private immutable _hashedName;\\n    bytes32 private immutable _hashedVersion;\\n\\n    ShortString private immutable _name;\\n    ShortString private immutable _version;\\n    string private _nameFallback;\\n    string private _versionFallback;\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        _name = name.toShortStringWithFallback(_nameFallback);\\n        _version = version.toShortStringWithFallback(_versionFallback);\\n        _hashedName = keccak256(bytes(name));\\n        _hashedVersion = keccak256(bytes(version));\\n\\n        _cachedChainId = block.chainid;\\n        _cachedDomainSeparator = _buildDomainSeparator();\\n        _cachedThis = address(this);\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\\n            return _cachedDomainSeparator;\\n        } else {\\n            return _buildDomainSeparator();\\n        }\\n    }\\n\\n    function _buildDomainSeparator() private view returns (bytes32) {\\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n\\n    /**\\n     * @dev See {IERC-5267}.\\n     */\\n    function eip712Domain()\\n        public\\n        view\\n        virtual\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        )\\n    {\\n        return (\\n            hex\\\"0f\\\", // 01111\\n            _EIP712Name(),\\n            _EIP712Version(),\\n            block.chainid,\\n            address(this),\\n            bytes32(0),\\n            new uint256[](0)\\n        );\\n    }\\n\\n    /**\\n     * @dev The name parameter for the EIP712 domain.\\n     *\\n     * NOTE: By default this function reads _name which is an immutable value.\\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function _EIP712Name() internal view returns (string memory) {\\n        return _name.toStringWithFallback(_nameFallback);\\n    }\\n\\n    /**\\n     * @dev The version parameter for the EIP712 domain.\\n     *\\n     * NOTE: By default this function reads _version which is an immutable value.\\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function _EIP712Version() internal view returns (string memory) {\\n        return _version.toStringWithFallback(_versionFallback);\\n    }\\n}\\n\",\"keccak256\":\"0x999f705a027ed6dc2d4e0df2cc4a509852c6bfd11de1c8161bf88832d0503fd0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Strings} from \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\\n *\\n * The library provides methods for generating a hash of a message that conforms to the\\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\\n * specifications.\\n */\\nlibrary MessageHashUtils {\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\n     * `0x45` (`personal_sign` messages).\\n     *\\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\\n     * `\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\"` and hashing the result. It corresponds with the\\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\\n     *\\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\\n     * keccak256, although any bytes32 value can be safely used because the final digest will\\n     * be re-hashed.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\") // 32 is the bytes-length of messageHash\\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\n     * `0x45` (`personal_sign` messages).\\n     *\\n     * The digest is calculated by prefixing an arbitrary `message` with\\n     * `\\\"\\\\x19Ethereum Signed Message:\\\\n\\\" + len(message)` and hashing the result. It corresponds with the\\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\\n        return\\n            keccak256(bytes.concat(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", bytes(Strings.toString(message.length)), message));\\n    }\\n\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\n     * `0x00` (data with intended validator).\\n     *\\n     * The digest is calculated by prefixing an arbitrary `data` with `\\\"\\\\x19\\\\x00\\\"` and the intended\\n     * `validator` address. Then hashing the result.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(hex\\\"19_00\\\", validator, data));\\n    }\\n\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\\n     *\\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\\n     * `\\\\x19\\\\x01` and hashing the result. It corresponds to the hash signed by the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, hex\\\"19_01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            digest := keccak256(ptr, 0x42)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xba333517a3add42cd35fe877656fc3dfcc9de53baa4f3aabbd6d12a92e4ea435\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\",\"keccak256\":\"0x005ec64c6313f0555d59e278f9a7a5ab2db5bdc72a027f255a37c327af1ec02d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5f7e4076e175393767754387c962926577f1660dd9b810187b9002407656be72\",\"license\":\"MIT\"},\"contracts/OnlyGrantsProtocol.sol\":{\"content\":\"pragma solidity >=0.8.19 <0.9.0;\\r\\n\\r\\nimport {Poll} from \\\"./Poll.sol\\\";\\r\\nimport {FHE, euint256, euint64, inEuint64, euint8} from \\\"@fhenixprotocol/contracts/FHE.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\r\\n\\r\\ncontract OnlyGrantsProtocol {\\r\\n  uint256 nextRoundId;\\r\\n\\r\\n  struct Round {\\r\\n    uint256 id;\\r\\n    address profileOwner;\\r\\n    string metadata;\\r\\n    uint256 matchingAmount;\\r\\n    bool isActive;\\r\\n    mapping(uint256 => Project) projects;\\r\\n    uint256[] projectIds;\\r\\n    uint256 nextProjectId;\\r\\n    Poll poll;\\r\\n  }\\r\\n\\r\\n  struct Project {\\r\\n    uint256 id;\\r\\n    address owner;\\r\\n    string metadata;\\r\\n    uint256 totalDonations;\\r\\n    uint64 impactAttestationId;\\r\\n    mapping(address => uint256) donations;\\r\\n    address[] donors;\\r\\n  }\\r\\n\\r\\n  mapping(uint256 => Round) public rounds;\\r\\n  mapping(address => uint256) public balances;\\r\\n\\r\\n  event RoundCreated(\\r\\n    uint256 indexed roundId,\\r\\n    address indexed profileOwner,\\r\\n    uint256 matchingAmount\\r\\n  );\\r\\n  event DonationMade(\\r\\n    uint256 indexed roundId,\\r\\n    uint256 indexed projectId,\\r\\n    address indexed donor,\\r\\n    euint64 amount\\r\\n  );\\r\\n  event FundsDistributed(uint256 indexed roundId);\\r\\n\\r\\n  event RoundCancelled(uint256 indexed roundId);\\r\\n  event ProjectApplied(\\r\\n    uint256 indexed roundId,\\r\\n    uint256 indexed projectId,\\r\\n    address indexed projectOwner\\r\\n  );\\r\\n  event BalanceToppedUp(address indexed user, uint256 amount);\\r\\n\\r\\n  function createRound(\\r\\n    uint256 ma,\\r\\n    string calldata m,\\r\\n    uint256 vp\\r\\n  ) external payable {\\r\\n    // require(ma > 0 && ma == msg.value, \\\"Invalid matching amount\\\");\\r\\n\\r\\n    uint256 rId = nextRoundId++;\\r\\n    Round storage r = rounds[rId];\\r\\n    r.id = rId;\\r\\n    r.profileOwner = msg.sender;\\r\\n    r.matchingAmount = ma;\\r\\n    r.metadata = m;\\r\\n    r.isActive = true;\\r\\n\\r\\n    r.poll = new Poll(m, new string[](1), vp);\\r\\n\\r\\n    emit RoundCreated(rId, msg.sender, ma);\\r\\n  }\\r\\n\\r\\n  function topUpBalance() external payable {\\r\\n    // require(msg.value > 0, \\\"Amount must be greater than 0\\\");\\r\\n    balances[msg.sender] += msg.value;\\r\\n    payable(msg.sender).transfer(msg.value);\\r\\n    emit BalanceToppedUp(msg.sender, msg.value);\\r\\n  }\\r\\n\\r\\n  function editRoundMetadata(\\r\\n    uint256 roundId,\\r\\n    string calldata newMetadata\\r\\n  ) external {\\r\\n    Round storage round = rounds[roundId];\\r\\n    // require(round.profileOwner == msg.sender, \\\"Not authorized\\\");\\r\\n\\r\\n    round.metadata = newMetadata;\\r\\n  }\\r\\n\\r\\n  /// @notice Creates a project to apply for a round\\r\\n  /// @param roundId The ID of the round to apply for\\r\\n  /// @param metadata The project's metadata\\r\\n  function applyForRound(uint256 roundId, string calldata metadata) external {\\r\\n    Round storage round = rounds[roundId];\\r\\n    // require(round.isActive, \\\"Round is not active\\\");\\r\\n\\r\\n    uint256 projectId = round.nextProjectId++;\\r\\n    Project storage project = round.projects[projectId];\\r\\n    // require(project.owner == address(0), \\\"Project ID already exists\\\");\\r\\n\\r\\n    project.id = projectId;\\r\\n    project.owner = msg.sender;\\r\\n    project.metadata = metadata;\\r\\n    project.totalDonations = (0);\\r\\n    round.projectIds.push(projectId);\\r\\n\\r\\n    round.poll.addOption(string(abi.encodePacked(projectId)));\\r\\n\\r\\n    emit ProjectApplied(roundId, projectId, msg.sender);\\r\\n  }\\r\\n\\r\\n  /// @notice Allows a user to donate to a specific project in a round\\r\\n  /// @param roundId The ID of the round\\r\\n  /// @param projectId The ID of the project\\r\\n  /// @param amount The amount of tokens to donate\\r\\n  function donate(\\r\\n    uint256 roundId,\\r\\n    uint256 projectId,\\r\\n    inEuint64 memory amount\\r\\n  ) external {\\r\\n    Round storage round = rounds[roundId];\\r\\n    euint64 encryptedAmount = FHE.asEuint64(amount);\\r\\n    uint256 decryptedAmount = FHE.decrypt(encryptedAmount);\\r\\n    // require(round.isActive, \\\"Round is not active\\\");\\r\\n\\r\\n    // require(balances[msg.sender] >= decryptedAmount, \\\"Insufficient balance\\\");\\r\\n\\r\\n    Project storage project = round.projects[projectId];\\r\\n    // require(project.owner != address(0), \\\"Project not found in round\\\");\\r\\n\\r\\n    uint256 newTotalDonations = project.totalDonations + decryptedAmount;\\r\\n\\r\\n    project.donations[msg.sender] = decryptedAmount;\\r\\n\\r\\n    project.totalDonations = newTotalDonations;\\r\\n\\r\\n    uint8 vote = uint8(projectId);\\r\\n    euint8 encryptedVote = FHE.asEuint8(vote);\\r\\n    round.poll.vote(encryptedVote, encryptedAmount);\\r\\n\\r\\n    balances[msg.sender] -= decryptedAmount;\\r\\n\\r\\n    emit DonationMade(roundId, projectId, msg.sender, encryptedAmount);\\r\\n  }\\r\\n\\r\\n  /// @notice Distributes funds for a completed round using quadratic funding\\r\\n  /// @param rId The ID of the round to distribute funds for\\r\\n  function distributeFunds(uint256 rId) external {\\r\\n    Round storage r = rounds[rId];\\r\\n    // require(\\r\\n    //   r.profileOwner == msg.sender && r.isActive,\\r\\n    //   \\\"Not authorized or inactive\\\"\\r\\n    // );\\r\\n\\r\\n    uint256 tMatch = r.matchingAmount;\\r\\n    uint256 tSqrtDonations = 0;\\r\\n\\r\\n    for (uint256 i = 0; i < r.projectIds.length; i++) {\\r\\n      Project storage p = r.projects[r.projectIds[i]];\\r\\n      tSqrtDonations += Math.sqrt(p.totalDonations);\\r\\n    }\\r\\n\\r\\n    for (uint256 i = 0; i < r.projectIds.length; i++) {\\r\\n      Project storage p = r.projects[r.projectIds[i]];\\r\\n      uint256 pShare = (Math.sqrt(p.totalDonations) * tMatch) / tSqrtDonations;\\r\\n      payable(p.owner).transfer(p.totalDonations + pShare);\\r\\n    }\\r\\n\\r\\n    r.isActive = false;\\r\\n    emit FundsDistributed(rId);\\r\\n  }\\r\\n\\r\\n  /// @notice Allows the round owner to cancel an active round and refund donations\\r\\n  /// @param roundId The ID of the round to cancel\\r\\n  function cancelRound(uint256 roundId) external {\\r\\n    Round storage round = rounds[roundId];\\r\\n    // require(round.profileOwner == msg.sender, \\\"Not round owner\\\");\\r\\n    // require(round.isActive, \\\"Round is not active\\\");\\r\\n\\r\\n    // Refund donations to donors\\r\\n    for (uint256 i = 0; i < round.projectIds.length; i++) {\\r\\n      Project storage project = round.projects[round.projectIds[i]];\\r\\n      for (uint256 j = 0; j < project.donors.length; j++) {\\r\\n        address donor = project.donors[j];\\r\\n        uint256 donation = project.donations[donor];\\r\\n        payable(donor).transfer(donation);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // Refund matching amount to round creator\\r\\n    payable(round.profileOwner).transfer(round.matchingAmount);\\r\\n\\r\\n    round.isActive = false;\\r\\n    emit RoundCancelled(roundId);\\r\\n  }\\r\\n\\r\\n  // New function to finalize a round's poll\\r\\n  function finalizeRoundPoll(uint256 roundId) external {\\r\\n    Round storage round = rounds[roundId];\\r\\n    // require(round.isActive, \\\"Round is not active\\\");\\r\\n    round.poll.finalize();\\r\\n  }\\r\\n\\r\\n  // New function to get the winning option of a round's poll\\r\\n  function getRoundPollWinner(\\r\\n    uint256 roundId\\r\\n  ) external view returns (uint8, uint16) {\\r\\n    Round storage round = rounds[roundId];\\r\\n    return round.poll.winning();\\r\\n  }\\r\\n}\\r\\n\",\"keccak256\":\"0x0d492c110746ca689ef6b6a60534e57e29c4fd09fba42852dfa2888742693840\"},\"contracts/Poll.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\r\\n\\r\\npragma solidity >=0.8.19 <0.9.0;\\r\\n\\r\\n// import \\\"@fhenixprotocol/contracts/FHE.sol\\\";\\r\\nimport \\\"@fhenixprotocol/contracts/FHE.sol\\\";\\r\\nimport \\\"@fhenixprotocol/contracts/access/Permissioned.sol\\\";\\r\\n\\r\\ncontract Poll is Permissioned {\\r\\n  uint8 internal constant MAX_OPTIONS = 4;\\r\\n\\r\\n  // Pre-compute these to prevent unnecessary gas usage for the users\\r\\n  euint16 internal _zero = FHE.asEuint16(0);\\r\\n  euint16 internal _one = FHE.asEuint16(1);\\r\\n  euint32 internal _u32Sixteen = FHE.asEuint32(16);\\r\\n  euint8[MAX_OPTIONS] internal _encOptions = [\\r\\n    FHE.asEuint8(0),\\r\\n    FHE.asEuint8(1),\\r\\n    FHE.asEuint8(2),\\r\\n    FHE.asEuint8(3)\\r\\n  ];\\r\\n\\r\\n  string public proposal;\\r\\n  string[] public options;\\r\\n  uint public voteEndTime;\\r\\n  euint16[MAX_OPTIONS] internal _tally; // Since every vote is worth 1, I assume we can use a 16-bit integer\\r\\n\\r\\n  euint8 internal _winningOption;\\r\\n  euint16 internal _winningTally;\\r\\n\\r\\n  mapping(address => euint8) internal _votes;\\r\\n  mapping(address => euint64) internal _voteAmounts;\\r\\n  address public owner;\\r\\n\\r\\n  constructor(\\r\\n    string memory _proposal,\\r\\n    string[] memory _options,\\r\\n    uint votingPeriod\\r\\n  ) {\\r\\n    require(options.length <= MAX_OPTIONS, \\\"too many options!\\\");\\r\\n    owner = msg.sender;\\r\\n    proposal = _proposal;\\r\\n    options = _options;\\r\\n    voteEndTime = block.timestamp + votingPeriod;\\r\\n  }\\r\\n\\r\\n  function vote(euint8 voteBytes, euint64 amount) public {\\r\\n    require(block.timestamp < voteEndTime, \\\"voting is over!\\\");\\r\\n    require(!FHE.isInitialized(_votes[msg.sender]), \\\"already voted!\\\");\\r\\n\\r\\n    euint8 encryptedVote = voteBytes; // Cast bytes into an encrypted type\\r\\n    euint64 encryptedAmount = amount;\\r\\n    _requireValid(encryptedVote);\\r\\n\\r\\n    _votes[msg.sender] = encryptedVote;\\r\\n    _voteAmounts[msg.sender] = encryptedAmount;\\r\\n    _addToTally(encryptedVote, FHE.asEuint16(encryptedAmount));\\r\\n  }\\r\\n\\r\\n  function finalize() public {\\r\\n    require(voteEndTime < block.timestamp, \\\"voting is still in progress!\\\");\\r\\n\\r\\n    _winningOption = _encOptions[0];\\r\\n    _winningTally = _tally[0];\\r\\n    for (uint8 i = 1; i < options.length; i++) {\\r\\n      euint16 newWinningTally = FHE.max(_winningTally, _tally[i]);\\r\\n      _winningOption = FHE.select(\\r\\n        newWinningTally.gt(_winningTally),\\r\\n        _encOptions[i],\\r\\n        _winningOption\\r\\n      );\\r\\n      _winningTally = newWinningTally;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function addOption(string memory _option) public {\\r\\n    require(options.length + 1 <= MAX_OPTIONS, \\\"too many options!\\\");\\r\\n    options.push(_option);\\r\\n  }\\r\\n\\r\\n  function winning() public view returns (uint8, uint16) {\\r\\n    // require(voteEndTime < block.timestamp, \\\"voting is still in progress!\\\");\\r\\n    return (FHE.decrypt(_winningOption), FHE.decrypt(_winningTally));\\r\\n  }\\r\\n\\r\\n  // function getSealedOutput(\\r\\n  //   Permission memory signature\\r\\n  // ) public view returns (string memory) {\\r\\n  //   // Seal the output for a specific publicKey\\r\\n  //   return FHE.sealoutput(_output, signature.publicKey);\\r\\n  // }\\r\\n\\r\\n  function getUserVote(\\r\\n    Permission memory signature\\r\\n  ) public view returns (string memory) {\\r\\n    require(FHE.isInitialized(_votes[msg.sender]), \\\"no vote found!\\\");\\r\\n    return FHE.sealoutput(_votes[msg.sender], signature.publicKey);\\r\\n  }\\r\\n\\r\\n  function _requireValid(euint8 encryptedVote) internal view {\\r\\n    // Make sure that: (0 <= vote <= options.length)\\r\\n    ebool isValid = encryptedVote.gte(_encOptions[0]) &\\r\\n      encryptedVote.lte(_encOptions[options.length - 1]);\\r\\n    FHE.req(isValid);\\r\\n  }\\r\\n\\r\\n  function _addToTally(euint8 option, euint16 amount) internal {\\r\\n    // We don't want to leak the user's vote, so we have to change the tally of every option.\\r\\n    // So for example, if the user voted for option 1:\\r\\n    // tally[0] = tally[0] + enc(0)\\r\\n    // tally[1] = tally[1] + enc(1)\\r\\n    // etc ..\\r\\n    for (uint8 i = 0; i < options.length; i++) {\\r\\n      euint16 amountOrZero = FHE.select(option.eq(_encOptions[i]), _one, _zero);\\r\\n\\r\\n      _tally[i] = _tally[i] + amountOrZero; // `eq()` result is known to be enc(0) or enc(1)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"keccak256\":\"0xdfe878abdd532a6ebc98f49e31810011caa1d18413ec8fe023b9118d8cbfcf2e\",\"license\":\"BSD-3-Clause-Clear\"}},\"version\":1}",
    "bytecode": "0x6080604052348015600f57600080fd5b50615cc18061001f6000396000f3fe60806040526004361061009c5760003560e01c80637efff887116100645780637efff887146101755780638c65c81f1461017f578063a0221f2e146101c2578063d13aae9b14610200578063f726f71514610229578063fe7776f5146102525761009c565b80630e7d2a20146100a157806327e235e3146100bd57806360d1abe4146100fa57806373e15a04146101235780637e07ab091461014c575b600080fd5b6100bb60048036038101906100b69190611566565b61027b565b005b3480156100c957600080fd5b506100e460048036038101906100df9190611638565b610453565b6040516100f19190611674565b60405180910390f35b34801561010657600080fd5b50610121600480360381019061011c919061168f565b61046b565b005b34801561012f57600080fd5b5061014a60048036038101906101459190611892565b610648565b005b34801561015857600080fd5b50610173600480360381019061016e9190611901565b610857565b005b61017d610a79565b005b34801561018b57600080fd5b506101a660048036038101906101a19190611901565b610b66565b6040516101b99796959493929190611a36565b60405180910390f35b3480156101ce57600080fd5b506101e960048036038101906101e49190611901565b610c7d565b6040516101f7929190611ae5565b60405180910390f35b34801561020c57600080fd5b5061022760048036038101906102229190611901565b610d33565b005b34801561023557600080fd5b50610250600480360381019061024b9190611901565b610dd2565b005b34801561025e57600080fd5b506102796004803603810190610274919061168f565b610fb3565b005b600080600081548092919061028f90611b3d565b9190505590506000600160008381526020019081526020016000209050818160000181905550338160010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508581600301819055508484826002019182610314929190611d92565b5060018160040160006101000a81548160ff0219169083151502179055508484600167ffffffffffffffff81111561034f5761034e611705565b5b60405190808252806020026020018201604052801561038257816020015b606081526020019060019003908161036d5790505b5085604051610390906114aa565b61039d9493929190611f9b565b604051809103906000f0801580156103b9573d6000803e3d6000fd5b508160080160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503373ffffffffffffffffffffffffffffffffffffffff16827fbc82faa03c047a80a167686652b69eb5982d8a57df6b65885f12bee8e4bce045886040516104439190611674565b60405180910390a3505050505050565b60026020528060005260406000206000915090505481565b6000600160008581526020019081526020016000209050600081600701600081548092919061049990611b3d565b91905055905060008260050160008381526020019081526020016000209050818160000181905550338160010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508484826002019182610517929190611d92565b5060008160030181905550826006018290806001815401808255809150506001900390600052602060002001600090919091909150558260080160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663edc550dc8360405160200161059e9190612003565b6040516020818303038152906040526040518263ffffffff1660e01b81526004016105c9919061201e565b600060405180830381600087803b1580156105e357600080fd5b505af11580156105f7573d6000803e3d6000fd5b505050503373ffffffffffffffffffffffffffffffffffffffff1682877f3d402e60eb8d9461fad9457ee1e3c1b5b64c4076b7862dd891018fd2d699287760405160405180910390a4505050505050565b6000600160008581526020019081526020016000209050600061066a83610fe4565b9050600061067782610ffa565b67ffffffffffffffff1690506000836005016000878152602001908152602001600020905060008282600301546106ae9190612040565b9050828260050160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550808260030181905550600087905060006107128260ff166110bd565b90508660080160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663b384abef82886040518363ffffffff1660e01b8152600401610773929190612092565b600060405180830381600087803b15801561078d57600080fd5b505af11580156107a1573d6000803e3d6000fd5b5050505084600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546107f491906120bb565b925050819055503373ffffffffffffffffffffffffffffffffffffffff16898b7fb9c87592ed73f7a26fff471ef513f8065a243208d84daa291fb0e770635014e28960405161084391906120ef565b60405180910390a450505050505050505050565b600060016000838152602001908152602001600020905060005b81600601805490508110156109bb57600082600501600084600601848154811061089e5761089d61210a565b5b90600052602060002001548152602001908152602001600020905060005b81600601805490508110156109ac5760008260060182815481106108e3576108e261210a565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905060008360050160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490508173ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f1935050505015801561099c573d6000803e3d6000fd5b50505080806001019150506108bc565b50508080600101915050610871565b508060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc82600301549081150290604051600060405180830381858888f19350505050158015610a2a573d6000803e3d6000fd5b5060008160040160006101000a81548160ff021916908315150217905550817fbf7aeff89cf7a4c3d0145879e39aa6a19e8e64ed585090ef86bf31f4d2ae57bf60405160405180910390a25050565b34600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254610ac89190612040565b925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc349081150290604051600060405180830381858888f19350505050158015610b15573d6000803e3d6000fd5b503373ffffffffffffffffffffffffffffffffffffffff167f068084e4fd39d69bcbf609dffcee86bf3143fb2c521113085f333cd9704ccc4e34604051610b5c9190611674565b60405180910390a2565b60016020528060005260406000206000915090508060000154908060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690806002018054610bb590611bbf565b80601f0160208091040260200160405190810160405280929190818152602001828054610be190611bbf565b8015610c2e5780601f10610c0357610100808354040283529160200191610c2e565b820191906000526020600020905b815481529060010190602001808311610c1157829003601f168201915b5050505050908060030154908060040160009054906101000a900460ff16908060070154908060080160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905087565b60008060006001600085815260200190815260200160002090508060080160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663853a1b906040518163ffffffff1660e01b81526004016040805180830381865afa158015610d05573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d299190612191565b9250925050915091565b60006001600083815260200190815260200160002090508060080160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16634bb278f36040518163ffffffff1660e01b8152600401600060405180830381600087803b158015610db657600080fd5b505af1158015610dca573d6000803e3d6000fd5b505050505050565b60006001600083815260200190815260200160002090506000816003015490506000805b8360060180549050811015610e66576000846005016000866006018481548110610e2357610e2261210a565b5b906000526020600020015481526020019081526020016000209050610e4b81600301546110d1565b83610e569190612040565b9250508080600101915050610df6565b5060005b8360060180549050811015610f62576000846005016000866006018481548110610e9757610e9661210a565b5b90600052602060002001548152602001908152602001600020905060008385610ec384600301546110d1565b610ecd91906121d1565b610ed79190612242565b90508160010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc828460030154610f279190612040565b9081150290604051600060405180830381858888f19350505050158015610f52573d6000803e3d6000fd5b5050508080600101915050610e6a565b5060008360040160006101000a81548160ff021916908315150217905550837f8eecd6f35243e1875b7143b093766263953bc97e6e92213e4ae934c67e1fe0de60405160405180910390a250505050565b60006001600085815260200190815260200160002090508282826002019182610fdd929190611d92565b5050505050565b6000610ff382600001516111ca565b9050919050565b6000611005826111de565b6110165761101360006111eb565b91505b60008290506000611026826111ff565b90506000608073ffffffffffffffffffffffffffffffffffffffff166373cc01546003846040518363ffffffff1660e01b81526004016110679291906122c8565b602060405180830381865afa158015611084573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a8919061230d565b90506110b38161125c565b9350505050919050565b60006110ca826000611266565b9050919050565b60008082036110e357600090506111c5565b600060016110f084611308565b901c6001901b9050600181848161110a57611109612213565b5b048201901c9050600181848161112357611122612213565b5b048201901c9050600181848161113c5761113b612213565b5b048201901c9050600181848161115557611154612213565b5b048201901c9050600181848161116e5761116d612213565b5b048201901c9050600181848161118757611186612213565b5b048201901c905060018184816111a05761119f612213565b5b048201901c90506111c1818285816111bb576111ba612213565b5b046113e9565b9150505b919050565b60006111d7826003611402565b9050919050565b6000808214159050919050565b60006111f8826003611266565b9050919050565b6060602067ffffffffffffffff81111561121c5761121b611705565b5b6040519080825280601f01601f19166020018201604052801561124e5781602001600182028036833780820191505090505b509050816020820152919050565b6000819050919050565b60006060608073ffffffffffffffffffffffffffffffffffffffff166319e1c5c4611290866111ff565b856040518363ffffffff1660e01b81526004016112ae92919061233a565b600060405180830381865afa1580156112cb573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906112f491906123da565b90506112ff8161149c565b91505092915050565b600080600090506000608084901c111561132a57608083901c92506080810190505b6000604084901c111561134557604083901c92506040810190505b6000602084901c111561136057602083901c92506020810190505b6000601084901c111561137b57601083901c92506010810190505b6000600884901c111561139657600883901c92506008810190505b6000600484901c11156113b157600483901c92506004810190505b6000600284901c11156113cc57600283901c92506002810190505b6000600184901c11156113e0576001810190505b80915050919050565b60008183106113f857816113fa565b825b905092915050565b60006060608073ffffffffffffffffffffffffffffffffffffffff16635fa55ca784866040518363ffffffff1660e01b81526004016114429291906122c8565b600060405180830381865afa15801561145f573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061148891906123da565b90506114938161149c565b91505092915050565b600060208201519050919050565b6138688061242483390190565b6000604051905090565b600080fd5b600080fd5b6000819050919050565b6114de816114cb565b81146114e957600080fd5b50565b6000813590506114fb816114d5565b92915050565b600080fd5b600080fd5b600080fd5b60008083601f84011261152657611525611501565b5b8235905067ffffffffffffffff81111561154357611542611506565b5b60208301915083600182028301111561155f5761155e61150b565b5b9250929050565b600080600080606085870312156115805761157f6114c1565b5b600061158e878288016114ec565b945050602085013567ffffffffffffffff8111156115af576115ae6114c6565b5b6115bb87828801611510565b935093505060406115ce878288016114ec565b91505092959194509250565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000611605826115da565b9050919050565b611615816115fa565b811461162057600080fd5b50565b6000813590506116328161160c565b92915050565b60006020828403121561164e5761164d6114c1565b5b600061165c84828501611623565b91505092915050565b61166e816114cb565b82525050565b60006020820190506116896000830184611665565b92915050565b6000806000604084860312156116a8576116a76114c1565b5b60006116b6868287016114ec565b935050602084013567ffffffffffffffff8111156116d7576116d66114c6565b5b6116e386828701611510565b92509250509250925092565b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61173d826116f4565b810181811067ffffffffffffffff8211171561175c5761175b611705565b5b80604052505050565b600061176f6114b7565b905061177b8282611734565b919050565b600080fd5b600080fd5b600067ffffffffffffffff8211156117a5576117a4611705565b5b6117ae826116f4565b9050602081019050919050565b82818337600083830152505050565b60006117dd6117d88461178a565b611765565b9050828152602081018484840111156117f9576117f8611785565b5b6118048482856117bb565b509392505050565b600082601f83011261182157611820611501565b5b81356118318482602086016117ca565b91505092915050565b6000602082840312156118505761184f6116ef565b5b61185a6020611765565b9050600082013567ffffffffffffffff81111561187a57611879611780565b5b6118868482850161180c565b60008301525092915050565b6000806000606084860312156118ab576118aa6114c1565b5b60006118b9868287016114ec565b93505060206118ca868287016114ec565b925050604084013567ffffffffffffffff8111156118eb576118ea6114c6565b5b6118f78682870161183a565b9150509250925092565b600060208284031215611917576119166114c1565b5b6000611925848285016114ec565b91505092915050565b611937816115fa565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b8381101561197757808201518184015260208101905061195c565b60008484015250505050565b600061198e8261193d565b6119988185611948565b93506119a8818560208601611959565b6119b1816116f4565b840191505092915050565b60008115159050919050565b6119d1816119bc565b82525050565b6000819050919050565b60006119fc6119f76119f2846115da565b6119d7565b6115da565b9050919050565b6000611a0e826119e1565b9050919050565b6000611a2082611a03565b9050919050565b611a3081611a15565b82525050565b600060e082019050611a4b600083018a611665565b611a58602083018961192e565b8181036040830152611a6a8188611983565b9050611a796060830187611665565b611a8660808301866119c8565b611a9360a0830185611665565b611aa060c0830184611a27565b98975050505050505050565b600060ff82169050919050565b611ac281611aac565b82525050565b600061ffff82169050919050565b611adf81611ac8565b82525050565b6000604082019050611afa6000830185611ab9565b611b076020830184611ad6565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611b48826114cb565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611b7a57611b79611b0e565b5b600182019050919050565b600082905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680611bd757607f821691505b602082108103611bea57611be9611b90565b5b50919050565b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b600060088302611c527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82611c15565b611c5c8683611c15565b95508019841693508086168417925050509392505050565b6000611c8f611c8a611c85846114cb565b6119d7565b6114cb565b9050919050565b6000819050919050565b611ca983611c74565b611cbd611cb582611c96565b848454611c22565b825550505050565b600090565b611cd2611cc5565b611cdd818484611ca0565b505050565b5b81811015611d0157611cf6600082611cca565b600181019050611ce3565b5050565b601f821115611d4657611d1781611bf0565b611d2084611c05565b81016020851015611d2f578190505b611d43611d3b85611c05565b830182611ce2565b50505b505050565b600082821c905092915050565b6000611d6960001984600802611d4b565b1980831691505092915050565b6000611d828383611d58565b9150826002028217905092915050565b611d9c8383611b85565b67ffffffffffffffff811115611db557611db4611705565b5b611dbf8254611bbf565b611dca828285611d05565b6000601f831160018114611df95760008415611de7578287013590505b611df18582611d76565b865550611e59565b601f198416611e0786611bf0565b60005b82811015611e2f57848901358255600182019150602085019450602081019050611e0a565b86831015611e4c5784890135611e48601f891682611d58565b8355505b6001600288020188555050505b50505050505050565b6000611e6e8385611948565b9350611e7b8385846117bb565b611e84836116f4565b840190509392505050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b600082825260208201905092915050565b6000611ed78261193d565b611ee18185611ebb565b9350611ef1818560208601611959565b611efa816116f4565b840191505092915050565b6000611f118383611ecc565b905092915050565b6000602082019050919050565b6000611f3182611e8f565b611f3b8185611e9a565b935083602082028501611f4d85611eab565b8060005b85811015611f895784840389528151611f6a8582611f05565b9450611f7583611f19565b925060208a01995050600181019050611f51565b50829750879550505050505092915050565b60006060820190508181036000830152611fb6818688611e62565b90508181036020830152611fca8185611f26565b9050611fd96040830184611665565b95945050505050565b6000819050919050565b611ffd611ff8826114cb565b611fe2565b82525050565b600061200f8284611fec565b60208201915081905092915050565b600060208201905081810360008301526120388184611983565b905092915050565b600061204b826114cb565b9150612056836114cb565b925082820190508082111561206e5761206d611b0e565b5b92915050565b61207d81611c74565b82525050565b61208c81611c74565b82525050565b60006040820190506120a76000830185612074565b6120b46020830184612083565b9392505050565b60006120c6826114cb565b91506120d1836114cb565b92508282039050818111156120e9576120e8611b0e565b5b92915050565b60006020820190506121046000830184612083565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b61214281611aac565b811461214d57600080fd5b50565b60008151905061215f81612139565b92915050565b61216e81611ac8565b811461217957600080fd5b50565b60008151905061218b81612165565b92915050565b600080604083850312156121a8576121a76114c1565b5b60006121b685828601612150565b92505060206121c78582860161217c565b9150509250929050565b60006121dc826114cb565b91506121e7836114cb565b92508282026121f5816114cb565b9150828204841483151761220c5761220b611b0e565b5b5092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600061224d826114cb565b9150612258836114cb565b92508261226857612267612213565b5b828204905092915050565b600081519050919050565b600082825260208201905092915050565b600061229a82612273565b6122a4818561227e565b93506122b4818560208601611959565b6122bd816116f4565b840191505092915050565b60006040820190506122dd6000830185611ab9565b81810360208301526122ef818461228f565b90509392505050565b600081519050612307816114d5565b92915050565b600060208284031215612323576123226114c1565b5b6000612331848285016122f8565b91505092915050565b60006040820190508181036000830152612354818561228f565b90506123636020830184611ab9565b9392505050565b600061237d6123788461178a565b611765565b90508281526020810184848401111561239957612398611785565b5b6123a4848285611959565b509392505050565b600082601f8301126123c1576123c0611501565b5b81516123d184826020860161236a565b91505092915050565b6000602082840312156123f0576123ef6114c1565b5b600082015167ffffffffffffffff81111561240e5761240d6114c6565b5b61241a848285016123ac565b9150509291505056fe61016060405261001560006102be60201b60201c565b60025561002860016102be60201b60201c565b60035561003b60106102d860201b60201c565b600455604051806080016040528061005960006102f260201b60201c565b815260200161006e60016102f260201b60201c565b815260200161008360026102f260201b60201c565b815260200161009860036102f260201b60201c565b81525060059060046100ab929190610542565b503480156100b857600080fd5b5060405161386838038061386883398181016040528101906100da919061090a565b6040518060400160405280601181526020017f4668656e6978205065726d697373696f6e0000000000000000000000000000008152506040518060400160405280600381526020017f312e30000000000000000000000000000000000000000000000000000000000081525061015a60008361030c60201b90919060201c565b610120818152505061017660018261030c60201b90919060201c565b6101408181525050818051906020012060e08181525050808051906020012061010081815250504660a081815250506101b361035c60201b60201c565b608081815250503073ffffffffffffffffffffffffffffffffffffffff1660c08173ffffffffffffffffffffffffffffffffffffffff16815250505050600460ff16600a80549050111561023c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610233906109f2565b60405180910390fd5b33601460006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550826009908161028c9190610c29565b5081600a90805190602001906102a3929190610582565b5080426102b09190610d2a565b600b8190555050505061108c565b60006102d18260016103b760201b60201c565b9050919050565b60006102eb8260026103b760201b60201c565b9050919050565b60006103058260006103b760201b60201c565b9050919050565b600060208351101561032e576103278361046560201b60201c565b9050610356565b8261033e836104cd60201b60201c565b600001908161034d9190610c29565b5060ff60001b90505b92915050565b60007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f60e05161010051463060405160200161039c959493929190610dc7565b60405160208183030381529060405280519060200120905090565b60006060608073ffffffffffffffffffffffffffffffffffffffff166319e1c5c46103e7866104d760201b60201c565b856040518363ffffffff1660e01b8152600401610405929190610e8b565b600060405180830381865afa158015610422573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061044b9190610f5c565b905061045c8161053460201b60201c565b91505092915050565b600080829050601f815111156104b257826040517f305a27a90000000000000000000000000000000000000000000000000000000081526004016104a99190610fde565b60405180910390fd5b8051816104be90611025565b60001c1760001b915050919050565b6000819050919050565b6060602067ffffffffffffffff8111156104f4576104f36106a8565b5b6040519080825280601f01601f1916602001820160405280156105265781602001600182028036833780820191505090505b509050816020820152919050565b600060208201519050919050565b8260048101928215610571579160200282015b82811115610570578251825591602001919060010190610555565b5b50905061057e91906105db565b5090565b8280548282559060005260206000209081019282156105ca579160200282015b828111156105c95782518290816105b99190610c29565b50916020019190600101906105a2565b5b5090506105d791906105f8565b5090565b5b808211156105f45760008160009055506001016105dc565b5090565b5b80821115610618576000818161060f919061061c565b506001016105f9565b5090565b50805461062890610a4c565b6000825580601f1061063a5750610659565b601f016020900490600052602060002090810190610658919061065c565b5b50565b5b8082111561067557600081600090555060010161065d565b5090565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6106e082610697565b810181811067ffffffffffffffff821117156106ff576106fe6106a8565b5b80604052505050565b6000610712610679565b905061071e82826106d7565b919050565b600067ffffffffffffffff82111561073e5761073d6106a8565b5b61074782610697565b9050602081019050919050565b60005b83811015610772578082015181840152602081019050610757565b60008484015250505050565b600061079161078c84610723565b610708565b9050828152602081018484840111156107ad576107ac610692565b5b6107b8848285610754565b509392505050565b600082601f8301126107d5576107d461068d565b5b81516107e584826020860161077e565b91505092915050565b600067ffffffffffffffff821115610809576108086106a8565b5b602082029050602081019050919050565b600080fd5b600061083261082d846107ee565b610708565b905080838252602082019050602084028301858111156108555761085461081a565b5b835b8181101561089c57805167ffffffffffffffff81111561087a5761087961068d565b5b80860161088789826107c0565b85526020850194505050602081019050610857565b5050509392505050565b600082601f8301126108bb576108ba61068d565b5b81516108cb84826020860161081f565b91505092915050565b6000819050919050565b6108e7816108d4565b81146108f257600080fd5b50565b600081519050610904816108de565b92915050565b60008060006060848603121561092357610922610683565b5b600084015167ffffffffffffffff81111561094157610940610688565b5b61094d868287016107c0565b935050602084015167ffffffffffffffff81111561096e5761096d610688565b5b61097a868287016108a6565b925050604061098b868287016108f5565b9150509250925092565b600082825260208201905092915050565b7f746f6f206d616e79206f7074696f6e7321000000000000000000000000000000600082015250565b60006109dc601183610995565b91506109e7826109a6565b602082019050919050565b60006020820190508181036000830152610a0b816109cf565b9050919050565b600081519050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680610a6457607f821691505b602082108103610a7757610a76610a1d565b5b50919050565b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b600060088302610adf7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82610aa2565b610ae98683610aa2565b95508019841693508086168417925050509392505050565b6000819050919050565b6000610b26610b21610b1c846108d4565b610b01565b6108d4565b9050919050565b6000819050919050565b610b4083610b0b565b610b54610b4c82610b2d565b848454610aaf565b825550505050565b600090565b610b69610b5c565b610b74818484610b37565b505050565b5b81811015610b9857610b8d600082610b61565b600181019050610b7a565b5050565b601f821115610bdd57610bae81610a7d565b610bb784610a92565b81016020851015610bc6578190505b610bda610bd285610a92565b830182610b79565b50505b505050565b600082821c905092915050565b6000610c0060001984600802610be2565b1980831691505092915050565b6000610c198383610bef565b9150826002028217905092915050565b610c3282610a12565b67ffffffffffffffff811115610c4b57610c4a6106a8565b5b610c558254610a4c565b610c60828285610b9c565b600060209050601f831160018114610c935760008415610c81578287015190505b610c8b8582610c0d565b865550610cf3565b601f198416610ca186610a7d565b60005b82811015610cc957848901518255600182019150602085019450602081019050610ca4565b86831015610ce65784890151610ce2601f891682610bef565b8355505b6001600288020188555050505b505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000610d35826108d4565b9150610d40836108d4565b9250828201905080821115610d5857610d57610cfb565b5b92915050565b6000819050919050565b610d7181610d5e565b82525050565b610d80816108d4565b82525050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610db182610d86565b9050919050565b610dc181610da6565b82525050565b600060a082019050610ddc6000830188610d68565b610de96020830187610d68565b610df66040830186610d68565b610e036060830185610d77565b610e106080830184610db8565b9695505050505050565b600081519050919050565b600082825260208201905092915050565b6000610e4182610e1a565b610e4b8185610e25565b9350610e5b818560208601610754565b610e6481610697565b840191505092915050565b600060ff82169050919050565b610e8581610e6f565b82525050565b60006040820190508181036000830152610ea58185610e36565b9050610eb46020830184610e7c565b9392505050565b600067ffffffffffffffff821115610ed657610ed56106a8565b5b610edf82610697565b9050602081019050919050565b6000610eff610efa84610ebb565b610708565b905082815260208101848484011115610f1b57610f1a610692565b5b610f26848285610754565b509392505050565b600082601f830112610f4357610f4261068d565b5b8151610f53848260208601610eec565b91505092915050565b600060208284031215610f7257610f71610683565b5b600082015167ffffffffffffffff811115610f9057610f8f610688565b5b610f9c84828501610f2e565b91505092915050565b6000610fb082610a12565b610fba8185610995565b9350610fca818560208601610754565b610fd381610697565b840191505092915050565b60006020820190508181036000830152610ff88184610fa5565b905092915050565b6000819050602082019050919050565b600061101c8251610d5e565b80915050919050565b600061103082610e1a565b8261103a84611000565b905061104581611010565b92506020821015611085576110807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83602003600802610aa2565b831692505b5050919050565b60805160a05160c05160e0516101005161012051610140516127916110d760003960006109ab01526000610970015260005050600050506000505060005050600050506127916000f3fe608060405234801561001057600080fd5b506004361061009e5760003560e01c8063853a1b9011610066578063853a1b901461014f5780638da5cb5b1461016e5780639e6cb42b1461018c578063b384abef146101aa578063edc550dc146101c65761009e565b8063409e2205146100a35780634bb278f3146100d35780635ad9fcca146100dd578063753ec1031461010d57806384b0196e1461012b575b600080fd5b6100bd60048036038101906100b891906116f1565b6101e2565b6040516100ca91906117ae565b60405180910390f35b6100db61028e565b005b6100f760048036038101906100f291906119b1565b6103a8565b60405161010491906117ae565b60405180910390f35b610115610485565b60405161012291906117ae565b60405180910390f35b610133610513565b6040516101469796959493929190611b52565b60405180910390f35b6101576105bd565b604051610165929190611c0f565b60405180910390f35b6101766105de565b6040516101839190611c38565b60405180910390f35b610194610604565b6040516101a19190611c53565b60405180910390f35b6101c460048036038101906101bf9190611cc6565b61060a565b005b6101e060048036038101906101db9190611da7565b610789565b005b600a81815481106101f257600080fd5b90600052602060002001600091509050805461020d90611e1f565b80601f016020809104026020016040519081016040528092919081815260200182805461023990611e1f565b80156102865780601f1061025b57610100808354040283529160200191610286565b820191906000526020600020905b81548152906001019060200180831161026957829003601f168201915b505050505081565b42600b54106102d2576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102c990611e9c565b60405180910390fd5b60056000600481106102e7576102e6611ebc565b5b0154601081905550600c60006004811061030457610303611ebc565b5b01546011819055506000600190505b600a805490508160ff1610156103a5576000610349601154600c8460ff166004811061034257610341611ebc565b5b0154610819565b90506103846103636011548361089290919063ffffffff16565b60058460ff166004811061037a57610379611ebc565b5b01546010546108a6565b6010819055508060118190555050808061039d90611f1a565b915050610313565b50565b60606103f2601260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054610924565b610431576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161042890611f8f565b60405180910390fd5b61047e601260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020548360000151610931565b9050919050565b6009805461049290611e1f565b80601f01602080910402602001604051908101604052809291908181526020018280546104be90611e1f565b801561050b5780601f106104e05761010080835404028352916020019161050b565b820191906000526020600020905b8154815290600101906020018083116104ee57829003601f168201915b505050505081565b600060608060008060006060610527610967565b61052f6109a2565b46306000801b600067ffffffffffffffff8111156105505761054f6117d5565b5b60405190808252806020026020018201604052801561057e5781602001602082028036833780820191505090505b507f0f00000000000000000000000000000000000000000000000000000000000000959493929190965096509650965096509650965090919293949596565b6000806105cb6010546109dd565b6105d6601154610aa0565b915091509091565b601460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600b5481565b600b54421061064e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161064590611ffb565b60405180910390fd5b610696601260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054610924565b156106d6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106cd90612067565b60405180910390fd5b600082905060008290506106e982610b63565b81601260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555080601360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506107838261077e83610bde565b610bf4565b50505050565b600460ff166001600a805490506107a09190612087565b11156107e1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107d890612107565b60405180910390fd5b600a8190806001815401808255809150506001900390600052602060002001600090919091909150908161081591906122d3565b5050565b600061082483610c9b565b610835576108326000610ca8565b92505b61083e82610c9b565b61084f5761084c6000610ca8565b91505b60008390506000839050600061088460018484608073ffffffffffffffffffffffffffffffffffffffff16630b80518e610cbc565b905080935050505092915050565b600061089e8383610d50565b905092915050565b60006108b184610dc9565b6108c2576108bf6000610dd6565b93505b6108cb83610924565b6108dc576108d96000610dea565b92505b6108e582610924565b6108f6576108f36000610dea565b91505b60008490506000849050600084905060006109146000858585610dfe565b9050809450505050509392505050565b6000808214159050919050565b606061093c83610924565b61094d5761094a6000610dea565b92505b600083905061095e60008285610eb6565b91505092915050565b606061099d60007f0000000000000000000000000000000000000000000000000000000000000000610f6c90919063ffffffff16565b905090565b60606109d860017f0000000000000000000000000000000000000000000000000000000000000000610f6c90919063ffffffff16565b905090565b60006109e882610924565b6109f9576109f66000610dea565b91505b60008290506000610a098261101c565b90506000608073ffffffffffffffffffffffffffffffffffffffff166373cc01546000846040518363ffffffff1660e01b8152600401610a4a9291906123fa565b602060405180830381865afa158015610a67573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a8b919061243f565b9050610a9681611079565b9350505050919050565b6000610aab82610c9b565b610abc57610ab96000610ca8565b91505b60008290506000610acc8261101c565b90506000608073ffffffffffffffffffffffffffffffffffffffff166373cc01546001846040518363ffffffff1660e01b8152600401610b0d9291906123fa565b602060405180830381865afa158015610b2a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b4e919061243f565b9050610b5981611083565b9350505050919050565b6000610bcf610b916005600060048110610b8057610b7f611ebc565b5b01548461108d90919063ffffffff16565b610bca60056001600a80549050610ba8919061246c565b60048110610bb957610bb8611ebc565b5b0154856110a190919063ffffffff16565b6110b5565b9050610bda816110c9565b5050565b6000610bed600383600161117e565b9050919050565b60005b600a805490508160ff161015610c96576000610c42610c3760058460ff1660048110610c2657610c25611ebc565b5b01548661122390919063ffffffff16565b600354600254611237565b9050610c66600c8360ff1660048110610c5e57610c5d611ebc565b5b0154826112b5565b600c8360ff1660048110610c7d57610c7c611ebc565b5b0181905550508080610c8e90611f1a565b915050610bf7565b505050565b6000808214159050919050565b6000610cb58260016112c9565b9050919050565b60006060838388610ccc8961101c565b610cd58961101c565b6040518463ffffffff1660e01b8152600401610cf3939291906124a0565b600060405180830381865afa158015610d10573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610d399190612555565b9050610d448161136b565b91505095945050505050565b6000610d5b83610c9b565b610d6c57610d696000610ca8565b92505b610d7582610c9b565b610d8657610d836000610ca8565b91505b600083905060008390506000610dbb60018484608073ffffffffffffffffffffffffffffffffffffffff1663874b1c10610cbc565b905080935050505092915050565b6000808214159050919050565b6000610de382600d6112c9565b9050919050565b6000610df78260006112c9565b9050919050565b60006060608073ffffffffffffffffffffffffffffffffffffffff1663c2d9695287610e298861101c565b610e328861101c565b610e3b8861101c565b6040518563ffffffff1660e01b8152600401610e5a949392919061259e565b600060405180830381865afa158015610e77573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610ea09190612555565b9050610eab81611379565b915050949350505050565b6060608073ffffffffffffffffffffffffffffffffffffffff1663a1848ff385610edf8661101c565b85604051602001610ef09190612619565b6040516020818303038152906040526040518463ffffffff1660e01b8152600401610f1d939291906124a0565b600060405180830381865afa158015610f3a573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610f6391906126a4565b90509392505050565b606060ff60001b8314610f8957610f8283611387565b9050611016565b818054610f9590611e1f565b80601f0160208091040260200160405190810160405280929190818152602001828054610fc190611e1f565b801561100e5780601f10610fe35761010080835404028352916020019161100e565b820191906000526020600020905b815481529060010190602001808311610ff157829003601f168201915b505050505090505b92915050565b6060602067ffffffffffffffff811115611039576110386117d5565b5b6040519080825280601f01601f19166020018201604052801561106b5781602001600182028036833780820191505090505b509050816020820152919050565b6000819050919050565b6000819050919050565b600061109983836113fb565b905092915050565b60006110ad8383611474565b905092915050565b60006110c183836114ed565b905092915050565b6110d281610dc9565b6110e3576110e06000610dd6565b90505b600081905060006110f38261101c565b9050608073ffffffffffffffffffffffffffffffffffffffff16637d23f1db600d836040518363ffffffff1660e01b81526004016111329291906123fa565b600060405180830381865afa15801561114f573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906111789190612555565b50505050565b60006060608073ffffffffffffffffffffffffffffffffffffffff16634a5a1117866111a98761101c565b866040518463ffffffff1660e01b81526004016111c8939291906126ed565b600060405180830381865afa1580156111e5573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061120e9190612555565b905061121981611379565b9150509392505050565b600061122f8383611566565b905092915050565b600061124284610dc9565b611253576112506000610dd6565b93505b61125c83610c9b565b61126d5761126a6000610ca8565b92505b61127682610c9b565b611287576112846000610ca8565b91505b60008490506000849050600084905060006112a56001858585610dfe565b9050809450505050509392505050565b60006112c183836115df565b905092915050565b60006060608073ffffffffffffffffffffffffffffffffffffffff166319e1c5c46112f38661101c565b856040518363ffffffff1660e01b815260040161131192919061272b565b600060405180830381865afa15801561132e573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906113579190612555565b905061136281611379565b91505092915050565b600060208201519050919050565b600060208201519050919050565b6060600061139483611657565b90506000602067ffffffffffffffff8111156113b3576113b26117d5565b5b6040519080825280601f01601f1916602001820160405280156113e55781602001600182028036833780820191505090505b5090508181528360208201528092505050919050565b600061140683610924565b611417576114146000610dea565b92505b61142082610924565b6114315761142e6000610dea565b91505b60008390506000839050600061146660008484608073ffffffffffffffffffffffffffffffffffffffff1663650de1cf610cbc565b905080935050505092915050565b600061147f83610924565b6114905761148d6000610dea565b92505b61149982610924565b6114aa576114a76000610dea565b91505b6000839050600083905060006114df60008484608073ffffffffffffffffffffffffffffffffffffffff1663eb274b77610cbc565b905080935050505092915050565b60006114f883610dc9565b611509576115066000610dd6565b92505b61151282610dc9565b611523576115206000610dd6565b91505b600083905060008390506000611558600d8484608073ffffffffffffffffffffffffffffffffffffffff1663ae104cfd610cbc565b905080935050505092915050565b600061157183610924565b6115825761157f6000610dea565b92505b61158b82610924565b61159c576115996000610dea565b91505b6000839050600083905060006115d160008484608073ffffffffffffffffffffffffffffffffffffffff166392348b34610cbc565b905080935050505092915050565b60006115ea83610c9b565b6115fb576115f86000610ca8565b92505b61160482610c9b565b611615576116126000610ca8565b91505b60008390506000839050600061164960018484608073ffffffffffffffffffffffffffffffffffffffff16622df619610cbc565b905080935050505092915050565b60008060ff8360001c169050601f81111561169e576040517fb3512b0c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80915050919050565b6000604051905090565b600080fd5b600080fd5b6000819050919050565b6116ce816116bb565b81146116d957600080fd5b50565b6000813590506116eb816116c5565b92915050565b600060208284031215611707576117066116b1565b5b6000611715848285016116dc565b91505092915050565b600081519050919050565b600082825260208201905092915050565b60005b8381101561175857808201518184015260208101905061173d565b60008484015250505050565b6000601f19601f8301169050919050565b60006117808261171e565b61178a8185611729565b935061179a81856020860161173a565b6117a381611764565b840191505092915050565b600060208201905081810360008301526117c88184611775565b905092915050565b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61180d82611764565b810181811067ffffffffffffffff8211171561182c5761182b6117d5565b5b80604052505050565b600061183f6116a7565b905061184b8282611804565b919050565b600080fd5b6000819050919050565b61186881611855565b811461187357600080fd5b50565b6000813590506118858161185f565b92915050565b600080fd5b600080fd5b600067ffffffffffffffff8211156118b0576118af6117d5565b5b6118b982611764565b9050602081019050919050565b82818337600083830152505050565b60006118e86118e384611895565b611835565b90508281526020810184848401111561190457611903611890565b5b61190f8482856118c6565b509392505050565b600082601f83011261192c5761192b61188b565b5b813561193c8482602086016118d5565b91505092915050565b60006040828403121561195b5761195a6117d0565b5b6119656040611835565b9050600061197584828501611876565b600083015250602082013567ffffffffffffffff81111561199957611998611850565b5b6119a584828501611917565b60208301525092915050565b6000602082840312156119c7576119c66116b1565b5b600082013567ffffffffffffffff8111156119e5576119e46116b6565b5b6119f184828501611945565b91505092915050565b60007fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b611a2f816119fa565b82525050565b611a3e816116bb565b82525050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000611a6f82611a44565b9050919050565b611a7f81611a64565b82525050565b611a8e81611855565b82525050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b611ac9816116bb565b82525050565b6000611adb8383611ac0565b60208301905092915050565b6000602082019050919050565b6000611aff82611a94565b611b098185611a9f565b9350611b1483611ab0565b8060005b83811015611b45578151611b2c8882611acf565b9750611b3783611ae7565b925050600181019050611b18565b5085935050505092915050565b600060e082019050611b67600083018a611a26565b8181036020830152611b798189611775565b90508181036040830152611b8d8188611775565b9050611b9c6060830187611a35565b611ba96080830186611a76565b611bb660a0830185611a85565b81810360c0830152611bc88184611af4565b905098975050505050505050565b600060ff82169050919050565b611bec81611bd6565b82525050565b600061ffff82169050919050565b611c0981611bf2565b82525050565b6000604082019050611c246000830185611be3565b611c316020830184611c00565b9392505050565b6000602082019050611c4d6000830184611a76565b92915050565b6000602082019050611c686000830184611a35565b92915050565b611c77816116bb565b8114611c8257600080fd5b50565b600081359050611c9481611c6e565b92915050565b611ca3816116bb565b8114611cae57600080fd5b50565b600081359050611cc081611c9a565b92915050565b60008060408385031215611cdd57611cdc6116b1565b5b6000611ceb85828601611c85565b9250506020611cfc85828601611cb1565b9150509250929050565b600067ffffffffffffffff821115611d2157611d206117d5565b5b611d2a82611764565b9050602081019050919050565b6000611d4a611d4584611d06565b611835565b905082815260208101848484011115611d6657611d65611890565b5b611d718482856118c6565b509392505050565b600082601f830112611d8e57611d8d61188b565b5b8135611d9e848260208601611d37565b91505092915050565b600060208284031215611dbd57611dbc6116b1565b5b600082013567ffffffffffffffff811115611ddb57611dda6116b6565b5b611de784828501611d79565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680611e3757607f821691505b602082108103611e4a57611e49611df0565b5b50919050565b7f766f74696e67206973207374696c6c20696e2070726f67726573732100000000600082015250565b6000611e86601c83611729565b9150611e9182611e50565b602082019050919050565b60006020820190508181036000830152611eb581611e79565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611f2582611bd6565b915060ff8203611f3857611f37611eeb565b5b600182019050919050565b7f6e6f20766f746520666f756e6421000000000000000000000000000000000000600082015250565b6000611f79600e83611729565b9150611f8482611f43565b602082019050919050565b60006020820190508181036000830152611fa881611f6c565b9050919050565b7f766f74696e67206973206f766572210000000000000000000000000000000000600082015250565b6000611fe5600f83611729565b9150611ff082611faf565b602082019050919050565b6000602082019050818103600083015261201481611fd8565b9050919050565b7f616c726561647920766f74656421000000000000000000000000000000000000600082015250565b6000612051600e83611729565b915061205c8261201b565b602082019050919050565b6000602082019050818103600083015261208081612044565b9050919050565b6000612092826116bb565b915061209d836116bb565b92508282019050808211156120b5576120b4611eeb565b5b92915050565b7f746f6f206d616e79206f7074696f6e7321000000000000000000000000000000600082015250565b60006120f1601183611729565b91506120fc826120bb565b602082019050919050565b60006020820190508181036000830152612120816120e4565b9050919050565b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b6000600883026121897fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8261214c565b612193868361214c565b95508019841693508086168417925050509392505050565b6000819050919050565b60006121d06121cb6121c6846116bb565b6121ab565b6116bb565b9050919050565b6000819050919050565b6121ea836121b5565b6121fe6121f6826121d7565b848454612159565b825550505050565b600090565b612213612206565b61221e8184846121e1565b505050565b5b818110156122425761223760008261220b565b600181019050612224565b5050565b601f8211156122875761225881612127565b6122618461213c565b81016020851015612270578190505b61228461227c8561213c565b830182612223565b50505b505050565b600082821c905092915050565b60006122aa6000198460080261228c565b1980831691505092915050565b60006122c38383612299565b9150826002028217905092915050565b6122dc8261171e565b67ffffffffffffffff8111156122f5576122f46117d5565b5b6122ff8254611e1f565b61230a828285612246565b600060209050601f83116001811461233d576000841561232b578287015190505b61233585826122b7565b86555061239d565b601f19841661234b86612127565b60005b828110156123735784890151825560018201915060208501945060208101905061234e565b86831015612390578489015161238c601f891682612299565b8355505b6001600288020188555050505b505050505050565b600081519050919050565b600082825260208201905092915050565b60006123cc826123a5565b6123d681856123b0565b93506123e681856020860161173a565b6123ef81611764565b840191505092915050565b600060408201905061240f6000830185611be3565b818103602083015261242181846123c1565b90509392505050565b600081519050612439816116c5565b92915050565b600060208284031215612455576124546116b1565b5b60006124638482850161242a565b91505092915050565b6000612477826116bb565b9150612482836116bb565b925082820390508181111561249a57612499611eeb565b5b92915050565b60006060820190506124b56000830186611be3565b81810360208301526124c781856123c1565b905081810360408301526124db81846123c1565b9050949350505050565b60006124f86124f384611895565b611835565b90508281526020810184848401111561251457612513611890565b5b61251f84828561173a565b509392505050565b600082601f83011261253c5761253b61188b565b5b815161254c8482602086016124e5565b91505092915050565b60006020828403121561256b5761256a6116b1565b5b600082015167ffffffffffffffff811115612589576125886116b6565b5b61259584828501612527565b91505092915050565b60006080820190506125b36000830187611be3565b81810360208301526125c581866123c1565b905081810360408301526125d981856123c1565b905081810360608301526125ed81846123c1565b905095945050505050565b6000819050919050565b61261361260e82611855565b6125f8565b82525050565b60006126258284612602565b60208201915081905092915050565b600061264761264284611d06565b611835565b90508281526020810184848401111561266357612662611890565b5b61266e84828561173a565b509392505050565b600082601f83011261268b5761268a61188b565b5b815161269b848260208601612634565b91505092915050565b6000602082840312156126ba576126b96116b1565b5b600082015167ffffffffffffffff8111156126d8576126d76116b6565b5b6126e484828501612676565b91505092915050565b60006060820190506127026000830186611be3565b818103602083015261271481856123c1565b90506127236040830184611be3565b949350505050565b6000604082019050818103600083015261274581856123c1565b90506127546020830184611be3565b939250505056fea264697066735822122048b50cc0537f954825d439e75edc87641386d1f561e695fee43fef59d980138864736f6c63430008190033a26469706673582212204b9de5af6067954a76acc6fa917706a112a27dceaf5fa7cf0c6e5352a1cf45b164736f6c63430008190033",
    "deployedBytecode": "0x60806040526004361061009c5760003560e01c80637efff887116100645780637efff887146101755780638c65c81f1461017f578063a0221f2e146101c2578063d13aae9b14610200578063f726f71514610229578063fe7776f5146102525761009c565b80630e7d2a20146100a157806327e235e3146100bd57806360d1abe4146100fa57806373e15a04146101235780637e07ab091461014c575b600080fd5b6100bb60048036038101906100b69190611566565b61027b565b005b3480156100c957600080fd5b506100e460048036038101906100df9190611638565b610453565b6040516100f19190611674565b60405180910390f35b34801561010657600080fd5b50610121600480360381019061011c919061168f565b61046b565b005b34801561012f57600080fd5b5061014a60048036038101906101459190611892565b610648565b005b34801561015857600080fd5b50610173600480360381019061016e9190611901565b610857565b005b61017d610a79565b005b34801561018b57600080fd5b506101a660048036038101906101a19190611901565b610b66565b6040516101b99796959493929190611a36565b60405180910390f35b3480156101ce57600080fd5b506101e960048036038101906101e49190611901565b610c7d565b6040516101f7929190611ae5565b60405180910390f35b34801561020c57600080fd5b5061022760048036038101906102229190611901565b610d33565b005b34801561023557600080fd5b50610250600480360381019061024b9190611901565b610dd2565b005b34801561025e57600080fd5b506102796004803603810190610274919061168f565b610fb3565b005b600080600081548092919061028f90611b3d565b9190505590506000600160008381526020019081526020016000209050818160000181905550338160010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508581600301819055508484826002019182610314929190611d92565b5060018160040160006101000a81548160ff0219169083151502179055508484600167ffffffffffffffff81111561034f5761034e611705565b5b60405190808252806020026020018201604052801561038257816020015b606081526020019060019003908161036d5790505b5085604051610390906114aa565b61039d9493929190611f9b565b604051809103906000f0801580156103b9573d6000803e3d6000fd5b508160080160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503373ffffffffffffffffffffffffffffffffffffffff16827fbc82faa03c047a80a167686652b69eb5982d8a57df6b65885f12bee8e4bce045886040516104439190611674565b60405180910390a3505050505050565b60026020528060005260406000206000915090505481565b6000600160008581526020019081526020016000209050600081600701600081548092919061049990611b3d565b91905055905060008260050160008381526020019081526020016000209050818160000181905550338160010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508484826002019182610517929190611d92565b5060008160030181905550826006018290806001815401808255809150506001900390600052602060002001600090919091909150558260080160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663edc550dc8360405160200161059e9190612003565b6040516020818303038152906040526040518263ffffffff1660e01b81526004016105c9919061201e565b600060405180830381600087803b1580156105e357600080fd5b505af11580156105f7573d6000803e3d6000fd5b505050503373ffffffffffffffffffffffffffffffffffffffff1682877f3d402e60eb8d9461fad9457ee1e3c1b5b64c4076b7862dd891018fd2d699287760405160405180910390a4505050505050565b6000600160008581526020019081526020016000209050600061066a83610fe4565b9050600061067782610ffa565b67ffffffffffffffff1690506000836005016000878152602001908152602001600020905060008282600301546106ae9190612040565b9050828260050160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550808260030181905550600087905060006107128260ff166110bd565b90508660080160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663b384abef82886040518363ffffffff1660e01b8152600401610773929190612092565b600060405180830381600087803b15801561078d57600080fd5b505af11580156107a1573d6000803e3d6000fd5b5050505084600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546107f491906120bb565b925050819055503373ffffffffffffffffffffffffffffffffffffffff16898b7fb9c87592ed73f7a26fff471ef513f8065a243208d84daa291fb0e770635014e28960405161084391906120ef565b60405180910390a450505050505050505050565b600060016000838152602001908152602001600020905060005b81600601805490508110156109bb57600082600501600084600601848154811061089e5761089d61210a565b5b90600052602060002001548152602001908152602001600020905060005b81600601805490508110156109ac5760008260060182815481106108e3576108e261210a565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905060008360050160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490508173ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f1935050505015801561099c573d6000803e3d6000fd5b50505080806001019150506108bc565b50508080600101915050610871565b508060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc82600301549081150290604051600060405180830381858888f19350505050158015610a2a573d6000803e3d6000fd5b5060008160040160006101000a81548160ff021916908315150217905550817fbf7aeff89cf7a4c3d0145879e39aa6a19e8e64ed585090ef86bf31f4d2ae57bf60405160405180910390a25050565b34600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254610ac89190612040565b925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc349081150290604051600060405180830381858888f19350505050158015610b15573d6000803e3d6000fd5b503373ffffffffffffffffffffffffffffffffffffffff167f068084e4fd39d69bcbf609dffcee86bf3143fb2c521113085f333cd9704ccc4e34604051610b5c9190611674565b60405180910390a2565b60016020528060005260406000206000915090508060000154908060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690806002018054610bb590611bbf565b80601f0160208091040260200160405190810160405280929190818152602001828054610be190611bbf565b8015610c2e5780601f10610c0357610100808354040283529160200191610c2e565b820191906000526020600020905b815481529060010190602001808311610c1157829003601f168201915b5050505050908060030154908060040160009054906101000a900460ff16908060070154908060080160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905087565b60008060006001600085815260200190815260200160002090508060080160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663853a1b906040518163ffffffff1660e01b81526004016040805180830381865afa158015610d05573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d299190612191565b9250925050915091565b60006001600083815260200190815260200160002090508060080160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16634bb278f36040518163ffffffff1660e01b8152600401600060405180830381600087803b158015610db657600080fd5b505af1158015610dca573d6000803e3d6000fd5b505050505050565b60006001600083815260200190815260200160002090506000816003015490506000805b8360060180549050811015610e66576000846005016000866006018481548110610e2357610e2261210a565b5b906000526020600020015481526020019081526020016000209050610e4b81600301546110d1565b83610e569190612040565b9250508080600101915050610df6565b5060005b8360060180549050811015610f62576000846005016000866006018481548110610e9757610e9661210a565b5b90600052602060002001548152602001908152602001600020905060008385610ec384600301546110d1565b610ecd91906121d1565b610ed79190612242565b90508160010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc828460030154610f279190612040565b9081150290604051600060405180830381858888f19350505050158015610f52573d6000803e3d6000fd5b5050508080600101915050610e6a565b5060008360040160006101000a81548160ff021916908315150217905550837f8eecd6f35243e1875b7143b093766263953bc97e6e92213e4ae934c67e1fe0de60405160405180910390a250505050565b60006001600085815260200190815260200160002090508282826002019182610fdd929190611d92565b5050505050565b6000610ff382600001516111ca565b9050919050565b6000611005826111de565b6110165761101360006111eb565b91505b60008290506000611026826111ff565b90506000608073ffffffffffffffffffffffffffffffffffffffff166373cc01546003846040518363ffffffff1660e01b81526004016110679291906122c8565b602060405180830381865afa158015611084573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a8919061230d565b90506110b38161125c565b9350505050919050565b60006110ca826000611266565b9050919050565b60008082036110e357600090506111c5565b600060016110f084611308565b901c6001901b9050600181848161110a57611109612213565b5b048201901c9050600181848161112357611122612213565b5b048201901c9050600181848161113c5761113b612213565b5b048201901c9050600181848161115557611154612213565b5b048201901c9050600181848161116e5761116d612213565b5b048201901c9050600181848161118757611186612213565b5b048201901c905060018184816111a05761119f612213565b5b048201901c90506111c1818285816111bb576111ba612213565b5b046113e9565b9150505b919050565b60006111d7826003611402565b9050919050565b6000808214159050919050565b60006111f8826003611266565b9050919050565b6060602067ffffffffffffffff81111561121c5761121b611705565b5b6040519080825280601f01601f19166020018201604052801561124e5781602001600182028036833780820191505090505b509050816020820152919050565b6000819050919050565b60006060608073ffffffffffffffffffffffffffffffffffffffff166319e1c5c4611290866111ff565b856040518363ffffffff1660e01b81526004016112ae92919061233a565b600060405180830381865afa1580156112cb573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906112f491906123da565b90506112ff8161149c565b91505092915050565b600080600090506000608084901c111561132a57608083901c92506080810190505b6000604084901c111561134557604083901c92506040810190505b6000602084901c111561136057602083901c92506020810190505b6000601084901c111561137b57601083901c92506010810190505b6000600884901c111561139657600883901c92506008810190505b6000600484901c11156113b157600483901c92506004810190505b6000600284901c11156113cc57600283901c92506002810190505b6000600184901c11156113e0576001810190505b80915050919050565b60008183106113f857816113fa565b825b905092915050565b60006060608073ffffffffffffffffffffffffffffffffffffffff16635fa55ca784866040518363ffffffff1660e01b81526004016114429291906122c8565b600060405180830381865afa15801561145f573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061148891906123da565b90506114938161149c565b91505092915050565b600060208201519050919050565b6138688061242483390190565b6000604051905090565b600080fd5b600080fd5b6000819050919050565b6114de816114cb565b81146114e957600080fd5b50565b6000813590506114fb816114d5565b92915050565b600080fd5b600080fd5b600080fd5b60008083601f84011261152657611525611501565b5b8235905067ffffffffffffffff81111561154357611542611506565b5b60208301915083600182028301111561155f5761155e61150b565b5b9250929050565b600080600080606085870312156115805761157f6114c1565b5b600061158e878288016114ec565b945050602085013567ffffffffffffffff8111156115af576115ae6114c6565b5b6115bb87828801611510565b935093505060406115ce878288016114ec565b91505092959194509250565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000611605826115da565b9050919050565b611615816115fa565b811461162057600080fd5b50565b6000813590506116328161160c565b92915050565b60006020828403121561164e5761164d6114c1565b5b600061165c84828501611623565b91505092915050565b61166e816114cb565b82525050565b60006020820190506116896000830184611665565b92915050565b6000806000604084860312156116a8576116a76114c1565b5b60006116b6868287016114ec565b935050602084013567ffffffffffffffff8111156116d7576116d66114c6565b5b6116e386828701611510565b92509250509250925092565b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61173d826116f4565b810181811067ffffffffffffffff8211171561175c5761175b611705565b5b80604052505050565b600061176f6114b7565b905061177b8282611734565b919050565b600080fd5b600080fd5b600067ffffffffffffffff8211156117a5576117a4611705565b5b6117ae826116f4565b9050602081019050919050565b82818337600083830152505050565b60006117dd6117d88461178a565b611765565b9050828152602081018484840111156117f9576117f8611785565b5b6118048482856117bb565b509392505050565b600082601f83011261182157611820611501565b5b81356118318482602086016117ca565b91505092915050565b6000602082840312156118505761184f6116ef565b5b61185a6020611765565b9050600082013567ffffffffffffffff81111561187a57611879611780565b5b6118868482850161180c565b60008301525092915050565b6000806000606084860312156118ab576118aa6114c1565b5b60006118b9868287016114ec565b93505060206118ca868287016114ec565b925050604084013567ffffffffffffffff8111156118eb576118ea6114c6565b5b6118f78682870161183a565b9150509250925092565b600060208284031215611917576119166114c1565b5b6000611925848285016114ec565b91505092915050565b611937816115fa565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b8381101561197757808201518184015260208101905061195c565b60008484015250505050565b600061198e8261193d565b6119988185611948565b93506119a8818560208601611959565b6119b1816116f4565b840191505092915050565b60008115159050919050565b6119d1816119bc565b82525050565b6000819050919050565b60006119fc6119f76119f2846115da565b6119d7565b6115da565b9050919050565b6000611a0e826119e1565b9050919050565b6000611a2082611a03565b9050919050565b611a3081611a15565b82525050565b600060e082019050611a4b600083018a611665565b611a58602083018961192e565b8181036040830152611a6a8188611983565b9050611a796060830187611665565b611a8660808301866119c8565b611a9360a0830185611665565b611aa060c0830184611a27565b98975050505050505050565b600060ff82169050919050565b611ac281611aac565b82525050565b600061ffff82169050919050565b611adf81611ac8565b82525050565b6000604082019050611afa6000830185611ab9565b611b076020830184611ad6565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611b48826114cb565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611b7a57611b79611b0e565b5b600182019050919050565b600082905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680611bd757607f821691505b602082108103611bea57611be9611b90565b5b50919050565b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b600060088302611c527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82611c15565b611c5c8683611c15565b95508019841693508086168417925050509392505050565b6000611c8f611c8a611c85846114cb565b6119d7565b6114cb565b9050919050565b6000819050919050565b611ca983611c74565b611cbd611cb582611c96565b848454611c22565b825550505050565b600090565b611cd2611cc5565b611cdd818484611ca0565b505050565b5b81811015611d0157611cf6600082611cca565b600181019050611ce3565b5050565b601f821115611d4657611d1781611bf0565b611d2084611c05565b81016020851015611d2f578190505b611d43611d3b85611c05565b830182611ce2565b50505b505050565b600082821c905092915050565b6000611d6960001984600802611d4b565b1980831691505092915050565b6000611d828383611d58565b9150826002028217905092915050565b611d9c8383611b85565b67ffffffffffffffff811115611db557611db4611705565b5b611dbf8254611bbf565b611dca828285611d05565b6000601f831160018114611df95760008415611de7578287013590505b611df18582611d76565b865550611e59565b601f198416611e0786611bf0565b60005b82811015611e2f57848901358255600182019150602085019450602081019050611e0a565b86831015611e4c5784890135611e48601f891682611d58565b8355505b6001600288020188555050505b50505050505050565b6000611e6e8385611948565b9350611e7b8385846117bb565b611e84836116f4565b840190509392505050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b600082825260208201905092915050565b6000611ed78261193d565b611ee18185611ebb565b9350611ef1818560208601611959565b611efa816116f4565b840191505092915050565b6000611f118383611ecc565b905092915050565b6000602082019050919050565b6000611f3182611e8f565b611f3b8185611e9a565b935083602082028501611f4d85611eab565b8060005b85811015611f895784840389528151611f6a8582611f05565b9450611f7583611f19565b925060208a01995050600181019050611f51565b50829750879550505050505092915050565b60006060820190508181036000830152611fb6818688611e62565b90508181036020830152611fca8185611f26565b9050611fd96040830184611665565b95945050505050565b6000819050919050565b611ffd611ff8826114cb565b611fe2565b82525050565b600061200f8284611fec565b60208201915081905092915050565b600060208201905081810360008301526120388184611983565b905092915050565b600061204b826114cb565b9150612056836114cb565b925082820190508082111561206e5761206d611b0e565b5b92915050565b61207d81611c74565b82525050565b61208c81611c74565b82525050565b60006040820190506120a76000830185612074565b6120b46020830184612083565b9392505050565b60006120c6826114cb565b91506120d1836114cb565b92508282039050818111156120e9576120e8611b0e565b5b92915050565b60006020820190506121046000830184612083565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b61214281611aac565b811461214d57600080fd5b50565b60008151905061215f81612139565b92915050565b61216e81611ac8565b811461217957600080fd5b50565b60008151905061218b81612165565b92915050565b600080604083850312156121a8576121a76114c1565b5b60006121b685828601612150565b92505060206121c78582860161217c565b9150509250929050565b60006121dc826114cb565b91506121e7836114cb565b92508282026121f5816114cb565b9150828204841483151761220c5761220b611b0e565b5b5092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600061224d826114cb565b9150612258836114cb565b92508261226857612267612213565b5b828204905092915050565b600081519050919050565b600082825260208201905092915050565b600061229a82612273565b6122a4818561227e565b93506122b4818560208601611959565b6122bd816116f4565b840191505092915050565b60006040820190506122dd6000830185611ab9565b81810360208301526122ef818461228f565b90509392505050565b600081519050612307816114d5565b92915050565b600060208284031215612323576123226114c1565b5b6000612331848285016122f8565b91505092915050565b60006040820190508181036000830152612354818561228f565b90506123636020830184611ab9565b9392505050565b600061237d6123788461178a565b611765565b90508281526020810184848401111561239957612398611785565b5b6123a4848285611959565b509392505050565b600082601f8301126123c1576123c0611501565b5b81516123d184826020860161236a565b91505092915050565b6000602082840312156123f0576123ef6114c1565b5b600082015167ffffffffffffffff81111561240e5761240d6114c6565b5b61241a848285016123ac565b9150509291505056fe61016060405261001560006102be60201b60201c565b60025561002860016102be60201b60201c565b60035561003b60106102d860201b60201c565b600455604051806080016040528061005960006102f260201b60201c565b815260200161006e60016102f260201b60201c565b815260200161008360026102f260201b60201c565b815260200161009860036102f260201b60201c565b81525060059060046100ab929190610542565b503480156100b857600080fd5b5060405161386838038061386883398181016040528101906100da919061090a565b6040518060400160405280601181526020017f4668656e6978205065726d697373696f6e0000000000000000000000000000008152506040518060400160405280600381526020017f312e30000000000000000000000000000000000000000000000000000000000081525061015a60008361030c60201b90919060201c565b610120818152505061017660018261030c60201b90919060201c565b6101408181525050818051906020012060e08181525050808051906020012061010081815250504660a081815250506101b361035c60201b60201c565b608081815250503073ffffffffffffffffffffffffffffffffffffffff1660c08173ffffffffffffffffffffffffffffffffffffffff16815250505050600460ff16600a80549050111561023c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610233906109f2565b60405180910390fd5b33601460006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550826009908161028c9190610c29565b5081600a90805190602001906102a3929190610582565b5080426102b09190610d2a565b600b8190555050505061108c565b60006102d18260016103b760201b60201c565b9050919050565b60006102eb8260026103b760201b60201c565b9050919050565b60006103058260006103b760201b60201c565b9050919050565b600060208351101561032e576103278361046560201b60201c565b9050610356565b8261033e836104cd60201b60201c565b600001908161034d9190610c29565b5060ff60001b90505b92915050565b60007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f60e05161010051463060405160200161039c959493929190610dc7565b60405160208183030381529060405280519060200120905090565b60006060608073ffffffffffffffffffffffffffffffffffffffff166319e1c5c46103e7866104d760201b60201c565b856040518363ffffffff1660e01b8152600401610405929190610e8b565b600060405180830381865afa158015610422573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061044b9190610f5c565b905061045c8161053460201b60201c565b91505092915050565b600080829050601f815111156104b257826040517f305a27a90000000000000000000000000000000000000000000000000000000081526004016104a99190610fde565b60405180910390fd5b8051816104be90611025565b60001c1760001b915050919050565b6000819050919050565b6060602067ffffffffffffffff8111156104f4576104f36106a8565b5b6040519080825280601f01601f1916602001820160405280156105265781602001600182028036833780820191505090505b509050816020820152919050565b600060208201519050919050565b8260048101928215610571579160200282015b82811115610570578251825591602001919060010190610555565b5b50905061057e91906105db565b5090565b8280548282559060005260206000209081019282156105ca579160200282015b828111156105c95782518290816105b99190610c29565b50916020019190600101906105a2565b5b5090506105d791906105f8565b5090565b5b808211156105f45760008160009055506001016105dc565b5090565b5b80821115610618576000818161060f919061061c565b506001016105f9565b5090565b50805461062890610a4c565b6000825580601f1061063a5750610659565b601f016020900490600052602060002090810190610658919061065c565b5b50565b5b8082111561067557600081600090555060010161065d565b5090565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6106e082610697565b810181811067ffffffffffffffff821117156106ff576106fe6106a8565b5b80604052505050565b6000610712610679565b905061071e82826106d7565b919050565b600067ffffffffffffffff82111561073e5761073d6106a8565b5b61074782610697565b9050602081019050919050565b60005b83811015610772578082015181840152602081019050610757565b60008484015250505050565b600061079161078c84610723565b610708565b9050828152602081018484840111156107ad576107ac610692565b5b6107b8848285610754565b509392505050565b600082601f8301126107d5576107d461068d565b5b81516107e584826020860161077e565b91505092915050565b600067ffffffffffffffff821115610809576108086106a8565b5b602082029050602081019050919050565b600080fd5b600061083261082d846107ee565b610708565b905080838252602082019050602084028301858111156108555761085461081a565b5b835b8181101561089c57805167ffffffffffffffff81111561087a5761087961068d565b5b80860161088789826107c0565b85526020850194505050602081019050610857565b5050509392505050565b600082601f8301126108bb576108ba61068d565b5b81516108cb84826020860161081f565b91505092915050565b6000819050919050565b6108e7816108d4565b81146108f257600080fd5b50565b600081519050610904816108de565b92915050565b60008060006060848603121561092357610922610683565b5b600084015167ffffffffffffffff81111561094157610940610688565b5b61094d868287016107c0565b935050602084015167ffffffffffffffff81111561096e5761096d610688565b5b61097a868287016108a6565b925050604061098b868287016108f5565b9150509250925092565b600082825260208201905092915050565b7f746f6f206d616e79206f7074696f6e7321000000000000000000000000000000600082015250565b60006109dc601183610995565b91506109e7826109a6565b602082019050919050565b60006020820190508181036000830152610a0b816109cf565b9050919050565b600081519050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680610a6457607f821691505b602082108103610a7757610a76610a1d565b5b50919050565b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b600060088302610adf7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82610aa2565b610ae98683610aa2565b95508019841693508086168417925050509392505050565b6000819050919050565b6000610b26610b21610b1c846108d4565b610b01565b6108d4565b9050919050565b6000819050919050565b610b4083610b0b565b610b54610b4c82610b2d565b848454610aaf565b825550505050565b600090565b610b69610b5c565b610b74818484610b37565b505050565b5b81811015610b9857610b8d600082610b61565b600181019050610b7a565b5050565b601f821115610bdd57610bae81610a7d565b610bb784610a92565b81016020851015610bc6578190505b610bda610bd285610a92565b830182610b79565b50505b505050565b600082821c905092915050565b6000610c0060001984600802610be2565b1980831691505092915050565b6000610c198383610bef565b9150826002028217905092915050565b610c3282610a12565b67ffffffffffffffff811115610c4b57610c4a6106a8565b5b610c558254610a4c565b610c60828285610b9c565b600060209050601f831160018114610c935760008415610c81578287015190505b610c8b8582610c0d565b865550610cf3565b601f198416610ca186610a7d565b60005b82811015610cc957848901518255600182019150602085019450602081019050610ca4565b86831015610ce65784890151610ce2601f891682610bef565b8355505b6001600288020188555050505b505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000610d35826108d4565b9150610d40836108d4565b9250828201905080821115610d5857610d57610cfb565b5b92915050565b6000819050919050565b610d7181610d5e565b82525050565b610d80816108d4565b82525050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610db182610d86565b9050919050565b610dc181610da6565b82525050565b600060a082019050610ddc6000830188610d68565b610de96020830187610d68565b610df66040830186610d68565b610e036060830185610d77565b610e106080830184610db8565b9695505050505050565b600081519050919050565b600082825260208201905092915050565b6000610e4182610e1a565b610e4b8185610e25565b9350610e5b818560208601610754565b610e6481610697565b840191505092915050565b600060ff82169050919050565b610e8581610e6f565b82525050565b60006040820190508181036000830152610ea58185610e36565b9050610eb46020830184610e7c565b9392505050565b600067ffffffffffffffff821115610ed657610ed56106a8565b5b610edf82610697565b9050602081019050919050565b6000610eff610efa84610ebb565b610708565b905082815260208101848484011115610f1b57610f1a610692565b5b610f26848285610754565b509392505050565b600082601f830112610f4357610f4261068d565b5b8151610f53848260208601610eec565b91505092915050565b600060208284031215610f7257610f71610683565b5b600082015167ffffffffffffffff811115610f9057610f8f610688565b5b610f9c84828501610f2e565b91505092915050565b6000610fb082610a12565b610fba8185610995565b9350610fca818560208601610754565b610fd381610697565b840191505092915050565b60006020820190508181036000830152610ff88184610fa5565b905092915050565b6000819050602082019050919050565b600061101c8251610d5e565b80915050919050565b600061103082610e1a565b8261103a84611000565b905061104581611010565b92506020821015611085576110807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83602003600802610aa2565b831692505b5050919050565b60805160a05160c05160e0516101005161012051610140516127916110d760003960006109ab01526000610970015260005050600050506000505060005050600050506127916000f3fe608060405234801561001057600080fd5b506004361061009e5760003560e01c8063853a1b9011610066578063853a1b901461014f5780638da5cb5b1461016e5780639e6cb42b1461018c578063b384abef146101aa578063edc550dc146101c65761009e565b8063409e2205146100a35780634bb278f3146100d35780635ad9fcca146100dd578063753ec1031461010d57806384b0196e1461012b575b600080fd5b6100bd60048036038101906100b891906116f1565b6101e2565b6040516100ca91906117ae565b60405180910390f35b6100db61028e565b005b6100f760048036038101906100f291906119b1565b6103a8565b60405161010491906117ae565b60405180910390f35b610115610485565b60405161012291906117ae565b60405180910390f35b610133610513565b6040516101469796959493929190611b52565b60405180910390f35b6101576105bd565b604051610165929190611c0f565b60405180910390f35b6101766105de565b6040516101839190611c38565b60405180910390f35b610194610604565b6040516101a19190611c53565b60405180910390f35b6101c460048036038101906101bf9190611cc6565b61060a565b005b6101e060048036038101906101db9190611da7565b610789565b005b600a81815481106101f257600080fd5b90600052602060002001600091509050805461020d90611e1f565b80601f016020809104026020016040519081016040528092919081815260200182805461023990611e1f565b80156102865780601f1061025b57610100808354040283529160200191610286565b820191906000526020600020905b81548152906001019060200180831161026957829003601f168201915b505050505081565b42600b54106102d2576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102c990611e9c565b60405180910390fd5b60056000600481106102e7576102e6611ebc565b5b0154601081905550600c60006004811061030457610303611ebc565b5b01546011819055506000600190505b600a805490508160ff1610156103a5576000610349601154600c8460ff166004811061034257610341611ebc565b5b0154610819565b90506103846103636011548361089290919063ffffffff16565b60058460ff166004811061037a57610379611ebc565b5b01546010546108a6565b6010819055508060118190555050808061039d90611f1a565b915050610313565b50565b60606103f2601260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054610924565b610431576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161042890611f8f565b60405180910390fd5b61047e601260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020548360000151610931565b9050919050565b6009805461049290611e1f565b80601f01602080910402602001604051908101604052809291908181526020018280546104be90611e1f565b801561050b5780601f106104e05761010080835404028352916020019161050b565b820191906000526020600020905b8154815290600101906020018083116104ee57829003601f168201915b505050505081565b600060608060008060006060610527610967565b61052f6109a2565b46306000801b600067ffffffffffffffff8111156105505761054f6117d5565b5b60405190808252806020026020018201604052801561057e5781602001602082028036833780820191505090505b507f0f00000000000000000000000000000000000000000000000000000000000000959493929190965096509650965096509650965090919293949596565b6000806105cb6010546109dd565b6105d6601154610aa0565b915091509091565b601460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600b5481565b600b54421061064e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161064590611ffb565b60405180910390fd5b610696601260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054610924565b156106d6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106cd90612067565b60405180910390fd5b600082905060008290506106e982610b63565b81601260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555080601360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506107838261077e83610bde565b610bf4565b50505050565b600460ff166001600a805490506107a09190612087565b11156107e1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107d890612107565b60405180910390fd5b600a8190806001815401808255809150506001900390600052602060002001600090919091909150908161081591906122d3565b5050565b600061082483610c9b565b610835576108326000610ca8565b92505b61083e82610c9b565b61084f5761084c6000610ca8565b91505b60008390506000839050600061088460018484608073ffffffffffffffffffffffffffffffffffffffff16630b80518e610cbc565b905080935050505092915050565b600061089e8383610d50565b905092915050565b60006108b184610dc9565b6108c2576108bf6000610dd6565b93505b6108cb83610924565b6108dc576108d96000610dea565b92505b6108e582610924565b6108f6576108f36000610dea565b91505b60008490506000849050600084905060006109146000858585610dfe565b9050809450505050509392505050565b6000808214159050919050565b606061093c83610924565b61094d5761094a6000610dea565b92505b600083905061095e60008285610eb6565b91505092915050565b606061099d60007f0000000000000000000000000000000000000000000000000000000000000000610f6c90919063ffffffff16565b905090565b60606109d860017f0000000000000000000000000000000000000000000000000000000000000000610f6c90919063ffffffff16565b905090565b60006109e882610924565b6109f9576109f66000610dea565b91505b60008290506000610a098261101c565b90506000608073ffffffffffffffffffffffffffffffffffffffff166373cc01546000846040518363ffffffff1660e01b8152600401610a4a9291906123fa565b602060405180830381865afa158015610a67573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a8b919061243f565b9050610a9681611079565b9350505050919050565b6000610aab82610c9b565b610abc57610ab96000610ca8565b91505b60008290506000610acc8261101c565b90506000608073ffffffffffffffffffffffffffffffffffffffff166373cc01546001846040518363ffffffff1660e01b8152600401610b0d9291906123fa565b602060405180830381865afa158015610b2a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b4e919061243f565b9050610b5981611083565b9350505050919050565b6000610bcf610b916005600060048110610b8057610b7f611ebc565b5b01548461108d90919063ffffffff16565b610bca60056001600a80549050610ba8919061246c565b60048110610bb957610bb8611ebc565b5b0154856110a190919063ffffffff16565b6110b5565b9050610bda816110c9565b5050565b6000610bed600383600161117e565b9050919050565b60005b600a805490508160ff161015610c96576000610c42610c3760058460ff1660048110610c2657610c25611ebc565b5b01548661122390919063ffffffff16565b600354600254611237565b9050610c66600c8360ff1660048110610c5e57610c5d611ebc565b5b0154826112b5565b600c8360ff1660048110610c7d57610c7c611ebc565b5b0181905550508080610c8e90611f1a565b915050610bf7565b505050565b6000808214159050919050565b6000610cb58260016112c9565b9050919050565b60006060838388610ccc8961101c565b610cd58961101c565b6040518463ffffffff1660e01b8152600401610cf3939291906124a0565b600060405180830381865afa158015610d10573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610d399190612555565b9050610d448161136b565b91505095945050505050565b6000610d5b83610c9b565b610d6c57610d696000610ca8565b92505b610d7582610c9b565b610d8657610d836000610ca8565b91505b600083905060008390506000610dbb60018484608073ffffffffffffffffffffffffffffffffffffffff1663874b1c10610cbc565b905080935050505092915050565b6000808214159050919050565b6000610de382600d6112c9565b9050919050565b6000610df78260006112c9565b9050919050565b60006060608073ffffffffffffffffffffffffffffffffffffffff1663c2d9695287610e298861101c565b610e328861101c565b610e3b8861101c565b6040518563ffffffff1660e01b8152600401610e5a949392919061259e565b600060405180830381865afa158015610e77573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610ea09190612555565b9050610eab81611379565b915050949350505050565b6060608073ffffffffffffffffffffffffffffffffffffffff1663a1848ff385610edf8661101c565b85604051602001610ef09190612619565b6040516020818303038152906040526040518463ffffffff1660e01b8152600401610f1d939291906124a0565b600060405180830381865afa158015610f3a573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610f6391906126a4565b90509392505050565b606060ff60001b8314610f8957610f8283611387565b9050611016565b818054610f9590611e1f565b80601f0160208091040260200160405190810160405280929190818152602001828054610fc190611e1f565b801561100e5780601f10610fe35761010080835404028352916020019161100e565b820191906000526020600020905b815481529060010190602001808311610ff157829003601f168201915b505050505090505b92915050565b6060602067ffffffffffffffff811115611039576110386117d5565b5b6040519080825280601f01601f19166020018201604052801561106b5781602001600182028036833780820191505090505b509050816020820152919050565b6000819050919050565b6000819050919050565b600061109983836113fb565b905092915050565b60006110ad8383611474565b905092915050565b60006110c183836114ed565b905092915050565b6110d281610dc9565b6110e3576110e06000610dd6565b90505b600081905060006110f38261101c565b9050608073ffffffffffffffffffffffffffffffffffffffff16637d23f1db600d836040518363ffffffff1660e01b81526004016111329291906123fa565b600060405180830381865afa15801561114f573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906111789190612555565b50505050565b60006060608073ffffffffffffffffffffffffffffffffffffffff16634a5a1117866111a98761101c565b866040518463ffffffff1660e01b81526004016111c8939291906126ed565b600060405180830381865afa1580156111e5573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061120e9190612555565b905061121981611379565b9150509392505050565b600061122f8383611566565b905092915050565b600061124284610dc9565b611253576112506000610dd6565b93505b61125c83610c9b565b61126d5761126a6000610ca8565b92505b61127682610c9b565b611287576112846000610ca8565b91505b60008490506000849050600084905060006112a56001858585610dfe565b9050809450505050509392505050565b60006112c183836115df565b905092915050565b60006060608073ffffffffffffffffffffffffffffffffffffffff166319e1c5c46112f38661101c565b856040518363ffffffff1660e01b815260040161131192919061272b565b600060405180830381865afa15801561132e573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906113579190612555565b905061136281611379565b91505092915050565b600060208201519050919050565b600060208201519050919050565b6060600061139483611657565b90506000602067ffffffffffffffff8111156113b3576113b26117d5565b5b6040519080825280601f01601f1916602001820160405280156113e55781602001600182028036833780820191505090505b5090508181528360208201528092505050919050565b600061140683610924565b611417576114146000610dea565b92505b61142082610924565b6114315761142e6000610dea565b91505b60008390506000839050600061146660008484608073ffffffffffffffffffffffffffffffffffffffff1663650de1cf610cbc565b905080935050505092915050565b600061147f83610924565b6114905761148d6000610dea565b92505b61149982610924565b6114aa576114a76000610dea565b91505b6000839050600083905060006114df60008484608073ffffffffffffffffffffffffffffffffffffffff1663eb274b77610cbc565b905080935050505092915050565b60006114f883610dc9565b611509576115066000610dd6565b92505b61151282610dc9565b611523576115206000610dd6565b91505b600083905060008390506000611558600d8484608073ffffffffffffffffffffffffffffffffffffffff1663ae104cfd610cbc565b905080935050505092915050565b600061157183610924565b6115825761157f6000610dea565b92505b61158b82610924565b61159c576115996000610dea565b91505b6000839050600083905060006115d160008484608073ffffffffffffffffffffffffffffffffffffffff166392348b34610cbc565b905080935050505092915050565b60006115ea83610c9b565b6115fb576115f86000610ca8565b92505b61160482610c9b565b611615576116126000610ca8565b91505b60008390506000839050600061164960018484608073ffffffffffffffffffffffffffffffffffffffff16622df619610cbc565b905080935050505092915050565b60008060ff8360001c169050601f81111561169e576040517fb3512b0c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80915050919050565b6000604051905090565b600080fd5b600080fd5b6000819050919050565b6116ce816116bb565b81146116d957600080fd5b50565b6000813590506116eb816116c5565b92915050565b600060208284031215611707576117066116b1565b5b6000611715848285016116dc565b91505092915050565b600081519050919050565b600082825260208201905092915050565b60005b8381101561175857808201518184015260208101905061173d565b60008484015250505050565b6000601f19601f8301169050919050565b60006117808261171e565b61178a8185611729565b935061179a81856020860161173a565b6117a381611764565b840191505092915050565b600060208201905081810360008301526117c88184611775565b905092915050565b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61180d82611764565b810181811067ffffffffffffffff8211171561182c5761182b6117d5565b5b80604052505050565b600061183f6116a7565b905061184b8282611804565b919050565b600080fd5b6000819050919050565b61186881611855565b811461187357600080fd5b50565b6000813590506118858161185f565b92915050565b600080fd5b600080fd5b600067ffffffffffffffff8211156118b0576118af6117d5565b5b6118b982611764565b9050602081019050919050565b82818337600083830152505050565b60006118e86118e384611895565b611835565b90508281526020810184848401111561190457611903611890565b5b61190f8482856118c6565b509392505050565b600082601f83011261192c5761192b61188b565b5b813561193c8482602086016118d5565b91505092915050565b60006040828403121561195b5761195a6117d0565b5b6119656040611835565b9050600061197584828501611876565b600083015250602082013567ffffffffffffffff81111561199957611998611850565b5b6119a584828501611917565b60208301525092915050565b6000602082840312156119c7576119c66116b1565b5b600082013567ffffffffffffffff8111156119e5576119e46116b6565b5b6119f184828501611945565b91505092915050565b60007fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b611a2f816119fa565b82525050565b611a3e816116bb565b82525050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000611a6f82611a44565b9050919050565b611a7f81611a64565b82525050565b611a8e81611855565b82525050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b611ac9816116bb565b82525050565b6000611adb8383611ac0565b60208301905092915050565b6000602082019050919050565b6000611aff82611a94565b611b098185611a9f565b9350611b1483611ab0565b8060005b83811015611b45578151611b2c8882611acf565b9750611b3783611ae7565b925050600181019050611b18565b5085935050505092915050565b600060e082019050611b67600083018a611a26565b8181036020830152611b798189611775565b90508181036040830152611b8d8188611775565b9050611b9c6060830187611a35565b611ba96080830186611a76565b611bb660a0830185611a85565b81810360c0830152611bc88184611af4565b905098975050505050505050565b600060ff82169050919050565b611bec81611bd6565b82525050565b600061ffff82169050919050565b611c0981611bf2565b82525050565b6000604082019050611c246000830185611be3565b611c316020830184611c00565b9392505050565b6000602082019050611c4d6000830184611a76565b92915050565b6000602082019050611c686000830184611a35565b92915050565b611c77816116bb565b8114611c8257600080fd5b50565b600081359050611c9481611c6e565b92915050565b611ca3816116bb565b8114611cae57600080fd5b50565b600081359050611cc081611c9a565b92915050565b60008060408385031215611cdd57611cdc6116b1565b5b6000611ceb85828601611c85565b9250506020611cfc85828601611cb1565b9150509250929050565b600067ffffffffffffffff821115611d2157611d206117d5565b5b611d2a82611764565b9050602081019050919050565b6000611d4a611d4584611d06565b611835565b905082815260208101848484011115611d6657611d65611890565b5b611d718482856118c6565b509392505050565b600082601f830112611d8e57611d8d61188b565b5b8135611d9e848260208601611d37565b91505092915050565b600060208284031215611dbd57611dbc6116b1565b5b600082013567ffffffffffffffff811115611ddb57611dda6116b6565b5b611de784828501611d79565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680611e3757607f821691505b602082108103611e4a57611e49611df0565b5b50919050565b7f766f74696e67206973207374696c6c20696e2070726f67726573732100000000600082015250565b6000611e86601c83611729565b9150611e9182611e50565b602082019050919050565b60006020820190508181036000830152611eb581611e79565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611f2582611bd6565b915060ff8203611f3857611f37611eeb565b5b600182019050919050565b7f6e6f20766f746520666f756e6421000000000000000000000000000000000000600082015250565b6000611f79600e83611729565b9150611f8482611f43565b602082019050919050565b60006020820190508181036000830152611fa881611f6c565b9050919050565b7f766f74696e67206973206f766572210000000000000000000000000000000000600082015250565b6000611fe5600f83611729565b9150611ff082611faf565b602082019050919050565b6000602082019050818103600083015261201481611fd8565b9050919050565b7f616c726561647920766f74656421000000000000000000000000000000000000600082015250565b6000612051600e83611729565b915061205c8261201b565b602082019050919050565b6000602082019050818103600083015261208081612044565b9050919050565b6000612092826116bb565b915061209d836116bb565b92508282019050808211156120b5576120b4611eeb565b5b92915050565b7f746f6f206d616e79206f7074696f6e7321000000000000000000000000000000600082015250565b60006120f1601183611729565b91506120fc826120bb565b602082019050919050565b60006020820190508181036000830152612120816120e4565b9050919050565b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b6000600883026121897fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8261214c565b612193868361214c565b95508019841693508086168417925050509392505050565b6000819050919050565b60006121d06121cb6121c6846116bb565b6121ab565b6116bb565b9050919050565b6000819050919050565b6121ea836121b5565b6121fe6121f6826121d7565b848454612159565b825550505050565b600090565b612213612206565b61221e8184846121e1565b505050565b5b818110156122425761223760008261220b565b600181019050612224565b5050565b601f8211156122875761225881612127565b6122618461213c565b81016020851015612270578190505b61228461227c8561213c565b830182612223565b50505b505050565b600082821c905092915050565b60006122aa6000198460080261228c565b1980831691505092915050565b60006122c38383612299565b9150826002028217905092915050565b6122dc8261171e565b67ffffffffffffffff8111156122f5576122f46117d5565b5b6122ff8254611e1f565b61230a828285612246565b600060209050601f83116001811461233d576000841561232b578287015190505b61233585826122b7565b86555061239d565b601f19841661234b86612127565b60005b828110156123735784890151825560018201915060208501945060208101905061234e565b86831015612390578489015161238c601f891682612299565b8355505b6001600288020188555050505b505050505050565b600081519050919050565b600082825260208201905092915050565b60006123cc826123a5565b6123d681856123b0565b93506123e681856020860161173a565b6123ef81611764565b840191505092915050565b600060408201905061240f6000830185611be3565b818103602083015261242181846123c1565b90509392505050565b600081519050612439816116c5565b92915050565b600060208284031215612455576124546116b1565b5b60006124638482850161242a565b91505092915050565b6000612477826116bb565b9150612482836116bb565b925082820390508181111561249a57612499611eeb565b5b92915050565b60006060820190506124b56000830186611be3565b81810360208301526124c781856123c1565b905081810360408301526124db81846123c1565b9050949350505050565b60006124f86124f384611895565b611835565b90508281526020810184848401111561251457612513611890565b5b61251f84828561173a565b509392505050565b600082601f83011261253c5761253b61188b565b5b815161254c8482602086016124e5565b91505092915050565b60006020828403121561256b5761256a6116b1565b5b600082015167ffffffffffffffff811115612589576125886116b6565b5b61259584828501612527565b91505092915050565b60006080820190506125b36000830187611be3565b81810360208301526125c581866123c1565b905081810360408301526125d981856123c1565b905081810360608301526125ed81846123c1565b905095945050505050565b6000819050919050565b61261361260e82611855565b6125f8565b82525050565b60006126258284612602565b60208201915081905092915050565b600061264761264284611d06565b611835565b90508281526020810184848401111561266357612662611890565b5b61266e84828561173a565b509392505050565b600082601f83011261268b5761268a61188b565b5b815161269b848260208601612634565b91505092915050565b6000602082840312156126ba576126b96116b1565b5b600082015167ffffffffffffffff8111156126d8576126d76116b6565b5b6126e484828501612676565b91505092915050565b60006060820190506127026000830186611be3565b818103602083015261271481856123c1565b90506127236040830184611be3565b949350505050565b6000604082019050818103600083015261274581856123c1565b90506127546020830184611be3565b939250505056fea264697066735822122048b50cc0537f954825d439e75edc87641386d1f561e695fee43fef59d980138864736f6c63430008190033a26469706673582212204b9de5af6067954a76acc6fa917706a112a27dceaf5fa7cf0c6e5352a1cf45b164736f6c63430008190033",
    "devdoc": {
        "kind": "dev",
        "methods": {
            "applyForRound(uint256,string)": {
                "params": {
                    "metadata": "The project's metadata",
                    "roundId": "The ID of the round to apply for"
                }
            },
            "cancelRound(uint256)": {
                "params": {
                    "roundId": "The ID of the round to cancel"
                }
            },
            "distributeFunds(uint256)": {
                "params": {
                    "rId": "The ID of the round to distribute funds for"
                }
            },
            "donate(uint256,uint256,(bytes))": {
                "params": {
                    "amount": "The amount of tokens to donate",
                    "projectId": "The ID of the project",
                    "roundId": "The ID of the round"
                }
            }
        },
        "version": 1
    },
    "userdoc": {
        "kind": "user",
        "methods": {
            "applyForRound(uint256,string)": {
                "notice": "Creates a project to apply for a round"
            },
            "cancelRound(uint256)": {
                "notice": "Allows the round owner to cancel an active round and refund donations"
            },
            "distributeFunds(uint256)": {
                "notice": "Distributes funds for a completed round using quadratic funding"
            },
            "donate(uint256,uint256,(bytes))": {
                "notice": "Allows a user to donate to a specific project in a round"
            }
        },
        "version": 1
    },
    "storageLayout": {
        "storage": [
            {
                "astId": 18004,
                "contract": "contracts/OnlyGrantsProtocol.sol:OnlyGrantsProtocol",
                "label": "nextRoundId",
                "offset": 0,
                "slot": "0",
                "type": "t_uint256"
            },
            {
                "astId": 18051,
                "contract": "contracts/OnlyGrantsProtocol.sol:OnlyGrantsProtocol",
                "label": "rounds",
                "offset": 0,
                "slot": "1",
                "type": "t_mapping(t_uint256,t_struct(Round)18028_storage)"
            },
            {
                "astId": 18055,
                "contract": "contracts/OnlyGrantsProtocol.sol:OnlyGrantsProtocol",
                "label": "balances",
                "offset": 0,
                "slot": "2",
                "type": "t_mapping(t_address,t_uint256)"
            }
        ],
        "types": {
            "t_address": {
                "encoding": "inplace",
                "label": "address",
                "numberOfBytes": "20"
            },
            "t_array(t_address)dyn_storage": {
                "base": "t_address",
                "encoding": "dynamic_array",
                "label": "address[]",
                "numberOfBytes": "32"
            },
            "t_array(t_uint256)dyn_storage": {
                "base": "t_uint256",
                "encoding": "dynamic_array",
                "label": "uint256[]",
                "numberOfBytes": "32"
            },
            "t_bool": {
                "encoding": "inplace",
                "label": "bool",
                "numberOfBytes": "1"
            },
            "t_contract(Poll)19069": {
                "encoding": "inplace",
                "label": "contract Poll",
                "numberOfBytes": "20"
            },
            "t_mapping(t_address,t_uint256)": {
                "encoding": "mapping",
                "key": "t_address",
                "label": "mapping(address => uint256)",
                "numberOfBytes": "32",
                "value": "t_uint256"
            },
            "t_mapping(t_uint256,t_struct(Project)18046_storage)": {
                "encoding": "mapping",
                "key": "t_uint256",
                "label": "mapping(uint256 => struct OnlyGrantsProtocol.Project)",
                "numberOfBytes": "32",
                "value": "t_struct(Project)18046_storage"
            },
            "t_mapping(t_uint256,t_struct(Round)18028_storage)": {
                "encoding": "mapping",
                "key": "t_uint256",
                "label": "mapping(uint256 => struct OnlyGrantsProtocol.Round)",
                "numberOfBytes": "32",
                "value": "t_struct(Round)18028_storage"
            },
            "t_string_storage": {
                "encoding": "bytes",
                "label": "string",
                "numberOfBytes": "32"
            },
            "t_struct(Project)18046_storage": {
                "encoding": "inplace",
                "label": "struct OnlyGrantsProtocol.Project",
                "members": [
                    {
                        "astId": 18030,
                        "contract": "contracts/OnlyGrantsProtocol.sol:OnlyGrantsProtocol",
                        "label": "id",
                        "offset": 0,
                        "slot": "0",
                        "type": "t_uint256"
                    },
                    {
                        "astId": 18032,
                        "contract": "contracts/OnlyGrantsProtocol.sol:OnlyGrantsProtocol",
                        "label": "owner",
                        "offset": 0,
                        "slot": "1",
                        "type": "t_address"
                    },
                    {
                        "astId": 18034,
                        "contract": "contracts/OnlyGrantsProtocol.sol:OnlyGrantsProtocol",
                        "label": "metadata",
                        "offset": 0,
                        "slot": "2",
                        "type": "t_string_storage"
                    },
                    {
                        "astId": 18036,
                        "contract": "contracts/OnlyGrantsProtocol.sol:OnlyGrantsProtocol",
                        "label": "totalDonations",
                        "offset": 0,
                        "slot": "3",
                        "type": "t_uint256"
                    },
                    {
                        "astId": 18038,
                        "contract": "contracts/OnlyGrantsProtocol.sol:OnlyGrantsProtocol",
                        "label": "impactAttestationId",
                        "offset": 0,
                        "slot": "4",
                        "type": "t_uint64"
                    },
                    {
                        "astId": 18042,
                        "contract": "contracts/OnlyGrantsProtocol.sol:OnlyGrantsProtocol",
                        "label": "donations",
                        "offset": 0,
                        "slot": "5",
                        "type": "t_mapping(t_address,t_uint256)"
                    },
                    {
                        "astId": 18045,
                        "contract": "contracts/OnlyGrantsProtocol.sol:OnlyGrantsProtocol",
                        "label": "donors",
                        "offset": 0,
                        "slot": "6",
                        "type": "t_array(t_address)dyn_storage"
                    }
                ],
                "numberOfBytes": "224"
            },
            "t_struct(Round)18028_storage": {
                "encoding": "inplace",
                "label": "struct OnlyGrantsProtocol.Round",
                "members": [
                    {
                        "astId": 18006,
                        "contract": "contracts/OnlyGrantsProtocol.sol:OnlyGrantsProtocol",
                        "label": "id",
                        "offset": 0,
                        "slot": "0",
                        "type": "t_uint256"
                    },
                    {
                        "astId": 18008,
                        "contract": "contracts/OnlyGrantsProtocol.sol:OnlyGrantsProtocol",
                        "label": "profileOwner",
                        "offset": 0,
                        "slot": "1",
                        "type": "t_address"
                    },
                    {
                        "astId": 18010,
                        "contract": "contracts/OnlyGrantsProtocol.sol:OnlyGrantsProtocol",
                        "label": "metadata",
                        "offset": 0,
                        "slot": "2",
                        "type": "t_string_storage"
                    },
                    {
                        "astId": 18012,
                        "contract": "contracts/OnlyGrantsProtocol.sol:OnlyGrantsProtocol",
                        "label": "matchingAmount",
                        "offset": 0,
                        "slot": "3",
                        "type": "t_uint256"
                    },
                    {
                        "astId": 18014,
                        "contract": "contracts/OnlyGrantsProtocol.sol:OnlyGrantsProtocol",
                        "label": "isActive",
                        "offset": 0,
                        "slot": "4",
                        "type": "t_bool"
                    },
                    {
                        "astId": 18019,
                        "contract": "contracts/OnlyGrantsProtocol.sol:OnlyGrantsProtocol",
                        "label": "projects",
                        "offset": 0,
                        "slot": "5",
                        "type": "t_mapping(t_uint256,t_struct(Project)18046_storage)"
                    },
                    {
                        "astId": 18022,
                        "contract": "contracts/OnlyGrantsProtocol.sol:OnlyGrantsProtocol",
                        "label": "projectIds",
                        "offset": 0,
                        "slot": "6",
                        "type": "t_array(t_uint256)dyn_storage"
                    },
                    {
                        "astId": 18024,
                        "contract": "contracts/OnlyGrantsProtocol.sol:OnlyGrantsProtocol",
                        "label": "nextProjectId",
                        "offset": 0,
                        "slot": "7",
                        "type": "t_uint256"
                    },
                    {
                        "astId": 18027,
                        "contract": "contracts/OnlyGrantsProtocol.sol:OnlyGrantsProtocol",
                        "label": "poll",
                        "offset": 0,
                        "slot": "8",
                        "type": "t_contract(Poll)19069"
                    }
                ],
                "numberOfBytes": "288"
            },
            "t_uint256": {
                "encoding": "inplace",
                "label": "uint256",
                "numberOfBytes": "32"
            },
            "t_uint64": {
                "encoding": "inplace",
                "label": "uint64",
                "numberOfBytes": "8"
            }
        }
    }
}